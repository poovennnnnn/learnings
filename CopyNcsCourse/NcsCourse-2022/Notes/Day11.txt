https://us02web.zoom.us/j/85867722382?pwd=TXFMQmtDa0Fpc29WQjdCZS9RSWlBQT09

Java Full Stack
day-1 22/aug/2022

Java + Spring-Spring Boot Microservices + Angular

JAVA SOFTWARE

Java 8

STS  : Spring Tool Suite
Eclipse IDE

IntelliJ

The JAVAC command : It is used to compile a Java program

  javac filename.java
  
 dir
 
  javac Test.java --> Test.class (BYTECODE)

  del Test.class

 The JAVA command : It is used to execute a compiled Java program

   java <name of the .class file which has a public static void main(String args[]) method inside it>

  java Test

  Your name
  Your education
  Your programming/web development skills


JAVA  -> MYSQL -> JDBC -> HTML,CSS,JAVASCRIPT,BOOTSTRAP-> SERVLETS,JSP->HIBERNATE->SPRING CORE->SPRING JPA-> SPRING MVC->SPRING REST->SPRING SECURITY ->SPRING BOOT->MICROSERVICES->(TYPESCRIPT)ANGULAR->DOCKER->PROJECT


What is Java?
Java is a high level object oriented programming language.

Java is used for developing different kinds of applications

1. Desktop applications ->
           retail store billing systems
           schools data entry systems
           hospital data entry systems

2. Web applications  (SERVLETs/JSP)
             online shopping
             ticket application

3. Embedded systems
                 ATM
                 Gaming devices
                 Any other chip devices
           

Java Editions
     JSE -  Java Standard Edition
     JEE -  Java Enterprise Edition
     JME - Java Micro Edition

Java Version History

JDK 1.0 1996  JDK 18


Java 4 - 5 -6 - 7 - 8 - 9 -10-11 

JDK
JVM
JRE
JDKTOOLS


JDK : Java Development Kit

JVM : Java virtual machine

JRE: Java Runtime Environment

JDK tools : These are the commands such as JAVAC, JAVA, JAR from the  "bin" folder of the JDK installation such as ../JAVA.X.Y.Z	

What is JDK?
JDK = JRE + JDK TOOLS

JRE = Java Libraries + JVM

JVM : Java Virtual Machine, It is that part of JDK, which is responsible for loading and executing the compiled java code

JVM 
  loads the byte code (from the .class file such as Test.class) when we say sometihng like "Java Test"
  converts BYTECODE to NATIVE CODE (CODE THAT AN OS UNDERSTANDS)
  and then NATIVE CODE is given to OS
  
OS will then execute it

JIT : Just In Time  compiler inside JVM

What does JIT do ?
  or
 What is the purpose of JIT?
 
 It fastens the conversion of BYTECODE to NATIVE CODE (machine code / object code)


  Welcome.java 


What are java libraries ?
  These are nothing but the  IN BUILT  (or ready made) java programs 
  
 All these IN BUILT java programs are compressed into  file with a file extension called .JAR (java archive)

  
 banking.jar
  movie-tickets.jar


What are JDK tools ?
  These are nothing but the commands such as JAVAC,  JAVA, JAR (and many more) which sit inside the "bin" of JDK installation path


   int i = 10;     -32768  to +32767
  long int x =12345678;

    i = x; n 4000
   print(i)25435

Java Features
 Object Oriented
 Platform independent
  Robust
 Simple
 Multithreaded
 
Understanding IDE
  Integrated Development Environment

Eclipse
STS
IntelliJ


A project is a colllection of different files such as .java files, .html files, .css files, .js, 

A workspace is a folder used by IDE such as STS/ECLIPSE to store all our projects

Perspective: A perspective is the window layout and feature display in IDE

 Java Perspective 
 Java EE perspective

Create a new java project
Create new "Java class" under "src"
syso Ctrl+Space  System.out.println
Ctrl+D  this will delete the line where the cursor is


Data types in Java
There are 8 primitive data types ( fundamental data types / basic data types)

byte     short          int         long        float        double
 1          2               4           8             4              8

char -   2

boolean - vendor specific (unspecified in the specification)


SYNTAX
 
 DATATTYPE  name-of-the-variable1, name-of-the-variable2 ....;

 byte b1=10;
  short s1;
  


 Samsung 22 - 

Everything thing such as length,width,thickness, camera, charging, audio,...  are called as specifcation 
Blueprint

A - high   10 colors

B - medium  5 colors

C-  poor  12 colors


if( expression ) {
    code to execute if expression is true
} else {
   code to execute if expression is false
}

----------------------------------------------------------
DAY-2 23/aug/2022

Casting and conversion

Casting and conversion refers to the process of changing the data type (or class/interface type) of a variable  (or an object )


byte v1 = 200;
int v2 = 200;

  v1 = v2 ;  //  we are trying to assing int (v2) to byte (v1);

 lower-data-type-variable = (lower-data-type) upper-datatype-variable;

 v1 = (byte) v2;


CASTING vs CONVERSION

 casting is an explicit action where we expliclity change wider type to narrow type

 conversion is an implicit action where narrow type is automatically changed to wider type


LOOPS

 A loop is a programming feature which


 while loop
 for loop
 do  while

for(part-1 ; part-2 ;part-3)

part-1 is for declarations or initializations
part-2 is for test condition (expression)
part-3 is for altering the value used in part-2

the do..while

do  {

   code block;
} while(test condition) ;


All number literals in java by default belong to "int" data type

  12 34 454 45 


   long x = 120L;

byte b1 = 20;  (- 128  to 127)

  b1 = (byte) (b1 * 2);  (40 is again inside -128 to 127)
         (int)

All decimal numbers belong to double data type in java by default
   float f1 = 12.3;
 float f1 = 12.3F;
  float f1 = (float) f1;


Class: A class in java can contain any of the following or none of the following 
  (i) variables
 (ii) methods (functions)
 (iii) constants
 (iv) nested classes (also called inner classes) 
 (v) enumerations
 (vi)nested interfaces (also called inner interfaces)
 



 syntax to declare a class

  class classname {
    list of variables
    list of methods
  list of nested classes
   list of nested interfaces
   list of enums    
  } 

 class Student {
   // list of variables
   int studentNumber;
   String studentFirstName;

  // list of methods
 void printStudentDetails(){
  System.out.println("Student Number = " +studentNumber);
   System.out.println("Student name = " + studentFirstName);
  }
 }




Object: An object is a special type of a variable whose data type is the name of a class (or an interface)


 datatype variable-name;
  int  x =10;
  byte z = 20;


         Student s1;

Members of an object. All items declared inside a class belong to an object and become its members

  how do we access the members that belong to an object
    object-name.membername

    s1.studentNumber = 101;
    s1.studentName="Scott";
   s1.printDetails(); // this line executes the printDetails() method of the object s1

Working with object, is a two step process

 #1. Declaring an object
               Student s1;  
   Declaration does not allocate space in memory to the members that belong to an object

 #2. Creating an object.
      Creating an object means, allocate space to the members that belong to an object. this is acheived
    by execute a line of code that contains the  new operator
     

 The new operator
    
   We use the new operator to create object

   syntax
       object-name = new class-name();

       s1 = new Student();


Product
   productId; (int)
   prodName;  (String) 
printProductDetails()


ProductMain1
   main()
   create two Product class objects
   fill the object data
   print them


Class and Interface naming best practice
  
  All classes and interfaces names are typed in PascalCase
  
 Employee
 Student
 EmployeeInsuranceDetails

 
All variable and method names are typed in camelCase

   firstName;
   lastName;


Movie ticket class and object.
  it should contain the relavant one or many methods to book tickets
  after tickets are booked,  it should then display
 
   Total Tickets available before booking
   Total tickets available after booking
    Total number of tickets booked

      if the number of tickets asked to book are more than the total number of available tickets, then a message something
 like insufficient tickets should be printed




PaySlipDetails

    double grossSalary=8000;

  deductions =   incomeTax, profidentFund, healthInsurance, carLoanEmi
  netSalary = grossSalary- deductions

 // print gross
 // print incomeTax
  // print..
 // print netSalary


PaySlipDetailsMain {

}


SalaryFinder {

  void   showSalary(String designation) {
     // using switch case display some salary  for a designation

 //  if it is manager 8K, clerk 5k, accountatnt 6k
   }
 }

 
SalaryFinderMain {
  public static void main(String args[]) {
   SalaryFinder finder = new SalaryFinder();
   finder.showSalary("manager");
   finder.showSalary("clerk");
  }
 }


Object of one class inside other class

class Address {
    String city;
    int zip;
    void printAddress() {
    System.out.println("City : " + city);
    System.out.println("Zip : " + zip);
  
  }
}
class Employee {
   int empCode;
   String empName;
   Address address = new Address() ;
    
   void printDetails() {
     System.out.println("Employee Code = " + empCode);
    System.out.println("Employee name = " + empName);
      address.printAddress();
   }
}

class EmployeeAndAddress {
   public static void main(String args[]) {


   Employee e1 = new Employee();
   e1.empCode=103;
   e1.empName="Scott";
   e1.address.zip=12346;
   e1.address.city="Some city";
 
    e1.printDetails();

Employee e2 = new Employee();
    e2.address=address;
    e2.address.city="Two city";

 }

}
  


static members and non static members inside a class

class A {
   int x;
  static int y;
 
   void m1(){

   }

   static void m2() {


  }
}


STATIC members appear as only one copy in memory for a class, no matter, whether we create 0 objects, 1 object , many objects of that class

There will always be one copy (one and only one copy) of a static member that exists in memory for  a class, even though we don't create an object, or we create 1 or more objects


There can be anything as a static or a non static member

There can be a block of code as static


What is the need for static ?
  Any thing which is best suitable to appear/occur only once need to be declared static


All static code (sometimes called static context)  is loaded into memory soon after it's .class file is loaded into memory

There can be any number of static blocks. 
All static blocks are merged into one according to their textual occurence and are executed soon after the .class file is loaded

 class X {
   static int v1;
  static void m1() {  }
   static{   }
   static class A {  }
  static interface B {  }
}


JVM makes a call to the main() method somehting like this one

  Test.main();  // classname.main()


Which members of a class are loaded first  ?
  static or non static 

We cannot use a non static code from inside a static code

class Test {
  int x = 10;
  public static void main(String args[]) {
   System.out.println(x);
  }

}

class Vendor {
   int vendorId;
   String vendorName;  
 ........
 
}

class Product {
   int prodId;
   String prodName;
   Vendor vendor;

}


class BankAccount {
    int actNum;
    double actBalance;
}


class Address {

 }
class Customer {
   int custId;
   String custName;
    BankAccount account;
    Address address;

}   

-------------------------------------------------------------------------
DAY-3 24/AUG/2022

Types of variables : 

1. Local variables
2. instance variables ( non static variables, fields, properties, attributes)
3. static variables (class variables)


1. Local variables.   These are declared inside a method and are local to the method inside which are declared

 e.g
    class Test {
     void method1() {
          int x=10, y=20;  // x and y are local to the method1
   }
 
    void method2() {
    int i=100, j=200;  // i and j are local to the method2
    int k;
    k++; // this is an compilaation error
   System.out.println(k); // this compilation error
   }

  }

  Local variables are not loaded into memory unless we assign them a value.
  Local variables are loaded into memory as soon as their method is loaded into the memory


class TestMain {
   public static void main(String args[]) {
   int x;
   x++;
    Test t1 = new Test();

       t1.method1() ;//  variables x and y are loaded into memory as soon as this line is executed
                            // variables x and y are removed from memory as soon as this method code is completed
      t1.method2(); // variables i , and j are loaded into memory as soon as this line is executed 
                           // however variable k is not loaded into memory and won't be in existence because there is no value to given it
                          
  }

 }

Local variables are stored in memory a partition named STACK


NON STATIC VARIABLES (INSTANCE VARIABLES)
Non static variables are declared inside the class declaration and outside of all methods 
They don't have a static keyword prefix
  byte short int long = 0
   float double = 0.0
   char  =  \u0000
  boolean  = false
  Any object reference (object name) will be null
 
 class Customer {  }
 class Student {   }
 class Product {   }
class TestMain {
    int x=15;    //  x, y , s1, c, s  are all instance variables
    int y;
    String s1="hello";
    String s2;
    Customer c1;
    Student std1 = new Student();
    Product p1 = new Product();


    void method1(int x, int y) {
  
     } 

    void method2() {
       int x;
    }

    public static void main(String args[]) {
    TestMain1  temp1 = new TestMain1();
   System.out.println(temp1.s1.length());
 System.out.println(temp1.s2.length());
     
   }
}

INSTANCE VARIABLES are loaded into memory and become into exisitence everytime an instance/object is created


  String s1;
  


class Customer {
   int custId;
   String custName;
   void printDetails(){
  System.out.println("Custid = "  + custId);
  System.out.println("Custname = "  + custName);
   }
}

class Student {
  int age;
 String name;
  void printAge() {
      System.out.println("Age = " + age);
  }
}

class Test {
   Student std1;  // null by default
   Customer c1;   // null by default
   String s1="Java is a programming lnauage";  // not null

   String s2 ;  // null by default
   public static void main(String args[]) {
   
    Test ob1 = new Test();
    ob1.std1.age=100;           // line 10
    ob1.c1.custId=1234;         // line 11
    ob1.c1.custName="Scott";   // line 12
    ob1.c1.printDetails();         // line 13
    ob1.std1.printAge();            // line 14
    System.out.println(ob1.s1.length()); // line 15
    System.out.println(ob1.s2.length());  // line 16

  }

}

All INSTANCE variables are removed from HEAP (Object heap) when a particular object is nullfied


class A {
   int x;
}

class Test{
 public static void main(String args[]) {
    A a1 = new A();
    a1 = null; // I am forcibly nullfying a1.  then all INSTANCE variables of a1 will be removed from HEAP
 }
 }


When are INSTANCE variables loaded into memory (HEAP) ?
  They are loaded when an instance is created

When are INSTANCE variables removed from memory (HEAP) ?
  they are removed when an object is destroyed.  object is detroyed when it is nullified.



STATIC VARIABLES ( class variables)

class A {
  static int x;
  static String s1;
 static Customer c1;
}

STATIC VARIABLES are loaded in method area

STATIC variables are loaded into memory as soon as the .class file is loaded 
STATIC variables are remvoed from memory as soon as the .class file is removed.

But when is the .class file remvoed from memory ?
  it is removed from memory when the JVM shutsdown

When does the JVM shut down ?
  when the program execution is completed



1. LOCAL VARIABLE
2. INSTANCE VARIABLE ( fields/ attributes/ properties)
3. CLASS VARIABLE


Class variables are stored on ____________
Instance variables are stored on ____________
Local varaibles are stored on ____________


class Test {

  public static void add(int x, int y) {
     int total ;
    System.out.println(total);
 }

 public static void main(String args[]) {
     add(1,2);
  }
}


public class customer-details {
   int Customer-Id;
 String  Customer-full-name;
   void PrintCustomerDetails() {

  }
}

class Address {
   static int zipcode=1234;
}
class Customer {
  int custId;
  String custName="Scott";
  Address address ;
}

class Student {
  int studentId;
  String studentName;
}

class Test {
   Customer c1 = new Customer();
 Student std1 = new Student();
  public static void main(String args[]) {
  Test t1 = new Test();
 System.out.println(t1.c1.address.zipcode);
  System.out.println(t1.std1.studentId);
  }

}


the "final" it has 3 different uses

1.  to declare constants
2. to prevent method overidding
3. to prevent a class from being extended/inherited


A constant is that data member whose value cannot be altered after it is assigned with a value for the first time

final int MAX_SCORE =100


All constants names are typed in UPPERCASE as a best a practice
If constant  name contains more than one word, then they are separated by an _

e.g
  final int MAX_SCORE=100;
  final int MIN_SCORE=20;

Note. Generally all constants are declared as static, it is not a rule though

class Test {
  static final int X=100;
  public static void main(String args[]) {
   Test t1 = new Test();
    Test t2 = new Test();
 }
}


the "this" pointer.
  
The JRE maintains a built in pointer,  this

The this pointer always points to the currently active object

Currently active object is that one, upon whose code JVM is currently executing

Encapsulation:  It is the process in which we bind (we encapsulate) both INSTANCE VARIABLES (data) and INSTANCE METHODS (code) into one single unit



Method overloading : Is the process in which, we can declare more than one method with the same name by following one rule

class Compute {
   public void add(byte x, byte y) {
    System.out.println("Inside two bytes version" + (x+y));
   }
   public void add(short x, short y) {
    System.out.println("Inside two shorts version" + (x+y));
   }
   public void add(int x, int y) {
    System.out.println("Inside two int version" + (x+y));
   }
   public void add(long  x, long y) {
    System.out.println("Inside two longs version" + (x+y));
   }
}


NOTE. When working with method overloading, it is required, that the different versions of the same method,
    (I) either must have different number of parameters
   (ii) OR, if they have same number of parameters, then their data types sequence must be different
  
 METHOD overloading, does not force that the  return type and access specifier to be NEITHER SAME NOR DIFFERENT

 class  Shape {

   area() // circle
   area() // square
   area() // triangle
 }

  class ShapeMain{

 }

class Address {
  private int zip;
 private   String city;
   getters/setters
}

class Student  {
    private int studentId;
    private String sname;
    private Address address;  
getters/setters
}
class Customer{
    private int customertId;
    private String cname;
    private Address address;  
getters/setters

}

class AddressOverload {
 
  public void printAddress(Student student) {
  // the code here should print the address of the student tobject
 }
  public void printAddress(Customer customer) {
  // the code here should print the address of the customer object
  }
}


class AddressOverloadMain {
  main(.......)  {
    // create an object address for student
   // create a student object, and fill stdId, sname, address 
   // repeate the above two for customer
  // create an object of AddressOverLoad
 // call the printAddress(Student)
  // call the printAddress(Customer)
}
}

Constructors:   
1 Constructor is a method of a class which has the same name as its class name (both spelling and case)
  
2. Constructor has NO return type

 e.g
       class Test {
           Test() {
            // some code here
        }
   }

3. Constructor is executed automatically ONCE per each object (and only time) during the object creation

4. Constructors are used to provide some initial values to the INSTANCE VARIABLES on an object

5. Default Constructor: A constructor that is automatically there for every class is called default constructor
 NOTE. Default constructor has NO PARAMETERS 
  Test t1  = new Test(10,100);
		Test t2 = new Test(20,200);
		Test t3=  new Test(30,300);
		
Test(int i, int j){
		System.out.println("hello from Test() cons...");
		this.i=i;
		this.j=j;
	}


class Engine {
   int cc;
   String model;
  getters/setters

}

class Car {
  String brand;
  Engine engine;
  getters/setters

}

Given a Car, we should get out the Engine from it and print cc, model


class BankAccount {
  int actBalance;
  String branchName;
  getter/setters
}


class Customer {
   int customerId;
   String customerName;
   BankAccount account;

getters/setters;
}


class CustomerMain {
  public static void main(String args[]) {
    // create an object of BankAccount
     BankAccount  b1 = new BankAccount();
              b1.setActBalance(10000);
              b1.setBranchName("branch-1");
   // create an object of Customer 
   Customer c1 = new Customer();
   // now fill the customerId;
      c1.setCustomerId(101);
  // now fill the customer Name
    c1.setCustomerName("Guest");
   // now insert the BankAcount object b1 into the customer object c1
      c1.setBankAccount(b1);
 }

}
___________________________________________________________________
DAY 4  25/AUG/2022

CONSTRUCTORS contd.

5. Default constructor
   A consrructor which has ZERO parameters is called default constructor
 
 e.g
       class Test {
         Test() {

     }

    }
6. Constructor overloading. We can overload constructors just like methods.   It means, there can be more than one constructor in a class. 

  e.g
    class Test {
        Test() {
         System.out.println("Constructor with zero parameters.  It is the default constructor");

     }

        Test(int i, int j) {
         System.out.println("Constructor with 2 parameters.  It is called the parameterized constructor");

     }

   Test(long i, int j) {
         System.out.println("Constructor with 2 parameters.  It is called the parameterized constructor");

     }


   }


public class Address {
     private int zip;
     private String city;

   // #1 default constr
  // #2 two parameter constructor zip, city

    getters/setters;

 }
 public class Customer {
  
      private int custId;
      private String custName;
      private Address address;


    // #1 default consructor
    // #2  Two parameter constructor  -- custId, custName
   // #3  Three paramater constructor -- custId, custName, Address object

 // getters/setters

      
 }

 public class CustomerConsMain {
    main(....) {
      //  #1 create a Customer with default parameters
     // #2  create a Customer object with two parameters
   //#3  create a Customer object with three parameters
  
    Address addr1 = new Address(); 
       addr1.setZip(1224);       addr.setCity("");
          Customer c1 = new Customer(param1, param2, addr1)

     Customer c3 = new Customer(1234, "Scott", new Address(param1, param2...) )

   // #4 print the c1 details
   // #5 print the c2 details
   //#6 print the c3 details

  // NOTE. for printing it is upto you
   }

 }

public class BankAccount {
   private int actNumber;
   private double actBalance;
   private Customer actCustomer;


   // #1  default cons (zero param cons..)
  // #2 two param cons .. actNumber, actBalance
  // #3  3 param cons.. actNumber, actBalance, actCustomer
 // getters/setters
 
  // method1  public void showBalance() {  Sop(actBalance)  }

  // # method2  public void withdraw(double howMuch)
 // while withdrawing, check if howMuch > actBalance.. print insufficient funds  otherwise withdraw
 // after withdrawing .. print balance before withdraw, and after withdrw

 // #method3 public void deposit(double howMuch)
 // just add howMuch to balance...
 // after depositing.. print balance before deposit and after deposit
 
  

}


public class BankAccountMain {
  main(...)  {
     // #1 BankAccount b1  with default cons
    // #2 BankAccount b2  with 2 param cons
   //#3 BankAccount b3  with 3 param cons

   // demonstrate withdraw and deposit on all b1, b2, b3
  // print the details of b1, b2, b3

  }
}


#7 the super()  constructor :  this one triggers call to the constructor of the immediate super class. (more on this during inheritance)

#8.  constructors can be declared using public, private, protected or default (no keyword) 

#9. Constructors CANNOT be static. if we try do so, it is a compilation failure

#10. Constrcutors CANNOT be final
 
#11. Constructors cannot be executed more than once

#12. the  this() constructor. There can be more than one overloaded constructor, and in such case, one version of a constructor can make a call to other version of a constructor using  this().   this() may take parameters


#13. If there is a call to this() then it MUST be the first statement

#14.  there is a tough competition between super() and this(), i.e
     super()  has to be the first statement (if we want to use super()  )
     this () has to be the first statement (if we want to use this()  )
     in otherwords, we cannot do something like the below 

    class A {

    A() {
    this();
    super();

   }
   A(int i) {

   }
   }

#15.  If we don't declare AT-LEAST (if we don't type) in a class's  .java file, then the compiler automatically adds the default constructor in that java file

  e.g
    what we type is the below one
    class Test {

    }
    what it becomes is the below one 
   class Test {
   Test() {

    }
  
  }


#16.  If we type atleast one constructor in a java file, then the compiler won't automatically provide the default constructor. we have to explicitily provide it


      what we type is the below one
    class Test {
     Test(int i) {

    }

  }
   what it becomes is the same. means, no default const (no param cons available)
      class Test {
      Test(int i) {

     }
    }


Arrays in Java.

 #1. An array is a collection of variables that have the same name with different index
 #2. Arrays in java are considered as objects , therefore we need to make of use of the "new" operator

      datatype name-of-the-array[] ;
      name-of-the-array = new datatype[array-size];

    int numbers[];  // only declaration happens. memory is not allocatedd
    numbers = new int[5] ; // now the array is created and memory is allocated to 5 items of the array

  datatype name-of-the-array[] =  new datatype[array-size];

   int numbers = new int[5]; // memory is allocated to 5 elements of the aray
 #1  five floats
 #2.  3 chars
 #3. 3 Strings
  #4.   3 Customers 
  #5.   3 Students


   int numbers[]  = new int[5];

All array elements are kind of instance variables of the respective array


 class Numbers {
      int numbers[0];
      int numbers[1];
     int numbers[2];
    int numbers[3];
    int numbers[4]
 }

Numbers numbers = new Numbers();
 

the "length" attribute of arrays.  Arrays in java like in JavaScript has a "length" 

ArrayIndexOutOfBoundsException : this is a class name from the Java library

If we refer to an array element beyond the array capacity, it is a successful compilation, but it fails during runtime with an exception called ArrayIndexOutOfBoundsException


Initializing an array. We can do this in two ways

1.   
datatype name-of-the-array[] = new datatype[] { val1, val2... valN };
 int numbers[] = new int[] { 10,23,45,54,56 };

2.   
datatype name-of-the-array[] = { val1, val2... valN };
 int numbers[] = { 10,23,45,54,56 };

Two dimensional array

 int numbers[][] = new int[2][2];

  String namesAndCities[][] = new String[3][3];
  
  
  int numbers[][] = {   
            { val1, val2, val3},
            { val1, val2, val3},
            { val1, val2, val3}
  };

  
  String strings[][] = {  
   {val1, val2, val3},
  {val1, val2, val3},
  {val1,val2,val3}
 };

 
the "enhanced for loop"  (also called as for..each loop)

for(Type t: arrayOrCollection) {

}

Java Command Line Arguments.
 
What are command line arguments?
  These are  the values that we can supply into the program
 VIA the command line (or console)

Part of the OOP, Encapsulation

Inheritance.
   In is an approach in Object Oriented Programming,  in which,
  one class inherits  the code/features of other class
  
 
  1. eliminating duplicate code
  2. acheiving POLYMORPHISM


class PermamentEmployee {
   private int empId;
   private String empName;
   private double grossSalary;
  costructors/ getters/setters/

  public void calculateNetSalary() {
   the net salary is calculated  by deducting all dedcutions from gross slaary
//  income tax + insuarance + emi + pf + hra 
  }
//  income tax + insuarance + emi + pf + hra 

}


class ContractEmployee {
   private int empId;
   private String empName;
   private double grossSalary;
  costructors/ getters/setters/

// fixed deduction of tax
  public void calculateNetSalary() {
   the net salary is calculated  by deducting fixed amount tax
   // fixed deduction of tax
  }
}


METHOD OVERRIDING.   
  It is an approach in which a child class redeclares a method (or any number of methods) of its parent class
 with same signature
 
 same signature means
  1. same return type
  2. same number of parameters
  3. same data type sequence of parameters 

In this explanation, the parent class version of method is called as overidden version
 the child class version of the method is called as overiding version
class A {
   void m1(int i, int j) {
   //some code goes here
  }
 }

class B extends A {
   void m1(int i, int  j) {
   //some code goes here
  }
}


class Test extends B{
    public static void main(String args[]) {
   B b1 = new B();
    b1.m1();
 }
}


A super class object reference can point to an object of any of its subclasses


A a1 = new A();

B b1 = new B();;

A a1 = new B();


-------------------------------------------------------------------------------------------
DAY 5  26/aug/2022


When a super class object reference points to an object of its subclass, then it has no knowledge about the 
exclusively declared members of the subclass.

It onlys know about the 
 (i) inherited members from the parent class
(ii) overriden members
 
  A a1 = new B();
class A {
   private int i;
   private int j;
 
   public void m1(int i) {

 }
  public void m2(int j) {

 }

}
class B extends A {
    private int x, y;
    public void m1(int i) {

    }
   public void m3(int j) {

  }
}

inherited members
overriden members
exclusive members

   
Employee e1;

PermanentEmployee p1 = new PermanentEmployee();
ContractEmployee c1 = new ContractEmployee();
  e1 = c1 ;  // line 1
  e1.showNetSalaryAfterDeductions(); // line2
   e1.printDetails();   // line 3
  e1 = p1;  // line 4
  e1.showNetSalaryAfterDeductions(); // line 5
   e1.printDetails(); // line 6
   
Abstract method. Any method which has JUST A DECLARATION, but no implmentation,
it is called as an abstract method.

Non abstract method . Any method which has an implementation is called no abstract method
CONCRETE methods.  Non abstract methods are also called as CONCRETE METHODS

abstract class: A class which contains ATLEAST one abstract method, is called as an abstract class


We cannot create an object for an abstract class


concrete class. A class with ZERO abstract methods inside it is called a concrete class


There can be an abstract class with ZERO abstract methods in it . (this is because, sometimes we may want to restrict people to create an object of our class)
abstract class Test1 {
    public void m1() { // some code here }
    public void m2() { // some code here }
    public void m3() { // some code here }
  }

abstract class Test2 {
    public void m1() { // some code here }
    public void m2() { // some code here }
    abstract public void m3() ;
  }

 class Test3 {
    public void m1() { // some code here }
    public void m2() { // some code here }
    abstract public void m3() ;
  }












class Test {
   public void m1() {
  // some code here
   }

  abstract public void m2() ;

  abstract public void m3();

  public void m4() {
  // some code here
  }

   abstract public void m5() {
   // some code here
   }

    abstract public void m6() {
  // some code here
    }
}



the "abstract" keyword. It  is used to declare abstract methods and abstract classes.


What are the abstract classes  and abstract methods  used for ?
   They are used in a situation, where there is a common code given by the parent class that is required by all children classes, and where there is a some functionlity  (some code) which is specific to each child


class FlightTicket {
  int flightNum;
  String origin;
 String detst;
   int depTime;
 
}

class EconomyTicket  extends FlightTicket{
   private String softDrinkName;
   getter/setter
  showBenefits() {
    boarding is oridnary
    seating is standard
   }
}

class BusinessClassTicket extends FlightTicket{
  private int freeExtraBaggageWeight;
  getter/setter
  showBenefits() {
     boarding is priority 
     seating is special seating
  }
}


bookTicket(FlightTicket t ) {

}

abstract class A {
    int i;
   abstract void m1();
}

class B extends A {

  void m1() {  } // overridden
   void m2() {  } // some exclusive method. neither inherited nor overridden
}

class C extends A {

  void m1() {  } // overridden
   void m3() {  } // some exclusive method. neither inherited nor overridden
}
class TestMain {
   public static void main(String args[]) {
          TestUtiliy.testMethod(new C() );
  }
 }
class TestUtitily {
   static void testMethod(A a) {
        a.m1();
   if(a instanceof B ) {
          B b1 = (B) a;
          b1.m2(); //works now
    } else  if (a instanceof C ) {
         C c1 = (C) a;
          c1.m3(); //works now

  }
}

if a is pointing to an instance of (object of) class B


Downcasting an object reference from parent class to child class name


PermanentEmployee i =10;
Employee x = 20;

 i =(PermanentEmployee) x;


The instanceof operator. It is used to check whether a given object reference points to an object of a specific class in need

A few points about an abstract class

1. We cannot create an object of an abstract class
2. abstract class can contain concrete methods and abstract methods
3. abstract class can contain constructors
4. An abstract method cannot be "final"
5. An abstract class can extend other class
6.An abstract can implement one or more interfaces 

V.IMP  If any class extends an abstract class, then that child class has to

EITHER override all abstract methods of abstract class , concretely

OR, the child class has to declare itself as abstract if it overrides few only method concretely

abstract class A extends Test {
   abstract void m1();
  abstract void m2();
   void m3() {}
    void m4() {}
}

abstract class B extends A  {

    void m2() {   // some code here }
   void m5() {  }
}
 
class C extends B {

    void m2() {  }
}

A a1 =new B();
  a1 = new C();

B b1 = new C();

class A {   }     class B {  }   class C  {  }

class D extends A,B,C {  } // this is not supported in Java, multiple inheritance


abstract class Shape {
    abstract void area();
    abstract void category();
   
}

class Triangle extends Shape {
    public void area() {  // some stuff here } 
}

class Rectanlge extends Shape {
  public void category() {  // some stuff here }
}

class MathAndScienceShape  extends Shape {
    public void area() { // some stuff here }
  public void category() {  // some stuff here }

}

class ScienceAndGeography extends Shape {

}

 DAO - Data Access Object
abstract class StoreData {
   abstract void storeInMongo();
   abstract void storeInMySQL();
   abstract void storeInOracle();
}




the super() constructor.  
   It executes a construtor of an immediate super class from within the constructor
 of a subclass
 
 super() .. is always there as a first statement in any constructor.

V IMP. When we create an object of a class, then, a list of constructors across all
 its super classes are executed from TOP to BOTTOM in descending order

 class A {   }
class B extends A { }
class C extends B {   }

the super keyword.  It is used to refer to the copy of a super class member from inside the code of a sub class member in case of duplicate names

 class A2 {
    int i =10;
    void m1() {
    System.out.println("m1 of class A ");
    }
  }

class B2 extends A2 {
   int i =20; 
   void m1() {
    
    System.out.println("m1 of class B");
   }
  void m2() {
    System.out.println("  I = "  + i) ; // this prints 20
    System.out.println(" super.i =  " + super.i); // this prints 10     
   m1(); // this calls  m1 of B
      super.m1(); // this calls m1 of A
   }
}


the  java.lang.Object class.  It is the implicit super class of all java classes.

class Test extends java.lang.Object{

}


the "final"  keyword. It has 3 uses

1. to declare CONSTANTS
2. to prevent method overriding
3. to prevent a class from being inherited 

final class A  {
void m1() {
      System.out.println("m1");
   }
 void m2() {
      System.out.println("m1");
   }
  void m3() {
      System.out.println("m1");
   }
  
}
class B extends A {
   void m1() {
     System.out.print("m1 of B");
    }
}


interfaces in java (with respect to versions upto  VERSION 7 (including 7).


An interface is a collection of 
  (i) CONSTANTS
 (ii) abstract methods

Interfaces are declared using the "interface" keyword

Interfaces ares are used to acheive 100% abstraction

interfaces are declared like the way classes are declared.

  interface interface-name {
    constant-1;
    constant-2; 
    constant-N;
 
   abstract-method-1;
   abstract-method-2;
   abstract-method-n;
 }


interface A {
 public static final int MAX_SCORE=10;
 public static final int MIN_SCORE=5;
public abstract void sum(int i, int j);
  public abstract void prod(int i, int j);

}

All data-items (data-members) such as MAX_SCORE,MIN_SCORE of an interface
are implicitly public, static, final.  which means, we can ignore those keywords.

All methods of an interface are implicitly public, abstract.

 A  a1 = new A(); // usesless-- because everything is abstract -- error

To make use of an interface, we need to create / declare a class that overrides all methods of an interface concretely and public ly


the "implements" keyword. This is used to establish a link between an interface and a class that  want to override the methods of that interface

class class-name implements interfacename-1, interface-name-2,interface-name-N {

}

In the following example, class TestA is said to implement the interface "A"
class TestA implements A {
public void sum(int i, int j) {  
  System.out.println("addition of i and j");  
}
  public void prod(int i, int j) {  }
  System.out.println("prod of i and j");
}

class TestMain4 {
  public static void main(String args[]) {
   A  ob1 = new TestA();
     ob1.sum(10,20);
    ob1.prod(1,2);
  System.out.println(A.MAX_SCORE);
  System.out.println(A.MAX_SCORE);

 }
 
}

To create a class that makes use of an interface different naming standards are followed as per the convenience

  the class-name + a suffix of the interface name

 e.g
   Test + A  = TestA // so that if we look at the class name we understand that class TestA isa class that implements interface

  the interface-name + a suffix of "Impl"

   e.g

   A + Impl = AImpl  // which means the class AImpl is an implementation of an interface A


One interface can have many implementation classes

e.g
   public interface StoreData {
     public abstract void insertRecord(Employee e);
    
  }
 
class MySqlStoreData implements StoreData {
   public void insertRecord(Employee e)  {
    // pull out the fields from e using something like e.getEmpId();
  // and then drop them in MySQL table
   }
}
 
class MongoDBStoreData implements StoreData {
   public void insertRecord(Employee e)  {
    // pull out the fields from e using something like e.getEmpId();
  // and then drop them in MongoDB
   }
}

class PdfStoreData implements StoreData {
   public void insertRecord(Employee e)  {
    // pull out the fields from e using something like e.getEmpId();
  // and then drop them in a pdf file
   }
}
 

Design a Banking operations

1. BankAccount as the parent class (with suitable parent class members)
2. SavingsBankAccount and CurrentBankAccount with suitable specific functionality of their own
       For e.g. SavingsBankAccount has a speficific functionaliy to itself  calculatSavingInterest
                   CurrentBankAccount has a specific functionality to itself  calculateOverDraftLimit
4. BankAccountUtility


1. LoanAccount
2. CarLoan,  HomeLoan, StudyLoan
3. LoanUtility


1. DeliveryPartner
2. OrdinaryDeliveryPartner, PriorityDeliveryPartner, InterntionalDeliveryPartner
3.

----------------------------------------------------------

DAY 6 29/AUG/2022

interface Circle {
   public abstract void drawCircle();
}

3 or 4 classes that implement the Circle interface, 

1. DrawSolidCircle
2. DrawHollowCircle
3. DrawSemiFilledCircle

#1 main method class, like  CircleMain1
  Inside the main method , create an object reference of Circle class  e.g. c1
  and c1 should point to different objects of the classes like DrawSolidCircle, and others and then call the drawCircle() method.

      System.out.println("now drawing solid circle...");


interface Payment 
     processPayment();


CreditCardPayment  : payment done by Credit Card
DebitCartPayment
InternetBankingPayment
PaypalPayment

PaymentMain

 "Booking a room in a hotel"
 
www.quickbooking.com

  hotels.. prices..  


www.easybooking.com

 hotels.. prices...


FEW POINTS ABOUT INTERFACES

1. We cannot create an object for an interface
           Circle c1 = new Circle() ;//  error , because Circle is an interface

2.  We can declare object reference to an interface
      Circle c1; //  c1 is an object reference to Circle interface

3.  The object reference of an interface CAN POINT to an object of any of it's implementation classes
      Circle c1 = new SolidCircle(); //   Circle is an interface, SolidCircle implements Circle interface

4. A class that implements an interface has to do one of the following
     (i) EITHER the class has to override all methods declared in the interface (public ly)
    (ii) OR, if the class  overrides one or few methods only, then the class has to be declared as an abstract class

5. A class can implement, as many interfaces as it want to (depending upon the problem statement's demand)
      interface One {  void m1() ; }      interface Two {  void m2(); }    interface Three { void m3(); }
     class OneTwoThreeImpl1  implements One, Two, Three {

      }
 
    class OneTwoThreeMain {
     main (....) {

    One one = new OneTwoThreeImpl() ;
       one.m1();  
       one.m2(); // fails
       one.m3(); // fails
     Two two = new OneTwoThreeImpl();
          two.m1(); // fails
           two.m2(); // works
          two.m3(); // fails

      }
    }


6. Java 8 onwards an interface can contain two special methods
   (i) default methods.  The methods declared using default keyword prefix 
   (ii) static methods.  the methods declared using static keyword prefix

7. Functional interface. (from Java version 8 onwards)

   @FunctionalInterface
     interface Test {
       public abstract void greet(String firstname, String lastname);


  }

Annotation.  An annotation is a java code with some name  with a combination of
   @ + some name

   e.g
    @FunctionalInterface
    @Override

8.   One interface may extend ZERO or MANY other interfaces
   

 interface One {  void m1() ; }      interface Two {  void m2(); }    

interface Three extends One, Two { 
void m3(); 
}

9. A class can extend one class, and implement zero or many interfaces
  
class  Greeting {
   public void happyNewYear(String guestName) {
    System.out.println("Happy new year = "  + guestName);
   }
}

interface Wish {
   public abstract void whatsYourWish(String wishName) ;
}
class TestGreetingWish  extends Greeting implements  Wish {
   public whatsYourWish(String wishName) {
  System.out.println("I hope your wish " + wishName + " is fulfilled ");
  }
}

class Main {
   public static void  main(String args[]) {
      TestGreetingWish ob1 = new TestGreetingWish(); 
      ob1.happyNewYear("Scott");
     ob1.whatsYourWish("take a roller coaster ride...");
  }
}




Interfaces are used to acheive abstraction.

Design pattern. What is it ?
  A design pattern defines an effective solution to solve a problem statement
There are so many design patterns.

Factory design pattern. is a pattern, which contains classes called as Factory class

The factory class is responsible for creating an object of the respective type during runtime based on the chosen one

public class StoreDataFactory  {
   


   public static StoreData createStoreData(String storeDataType) {
    if(storeDataType.equals("Mysql")) {
      return new MySqlStoreData();
    } else if (storeDataType.equals("Mongo"))  {
      return new MongoStoreData();
   }

   }

}

OOPs Object Oriented Programming system

Encapsulation : helps modifying instance variable names without the client's code broken
Inheritance : elimnate duplicate code and also ahceive polymorhphism
Polymorphism : acheive abstraction 
Abstraction: helps easy code maintenance


Packages in Java.
 A package in java is used to  put all related classes/interfaces into one logical group or folder

For e.g All database related classes and interfaces go inside a package called  "dao"

  All banking related classes and interfaces go inside a package "banking"

 all plain classes such as Product, BankAccount, Customer,  Employee go inside a package called "dto" (Data transfer object) (DataValue object) dvo,  beans

We create packages using "package" statement

e.g

 Test.java

   package p1;
   public class Test {

  }

 Hello.java

   package p1;
  public class Hello {

 }


Greeting.java

 package p2;
   public interface Greeting {

  }

NewYearGreeting.java

package greeting;
 public class NewYearGreeting implements Greeting{

 }

BirthdayGreeting.java

 package greeting;
 public class BirthdayGreeting implements Greeting{

}


GreetingMain.java

package greeting.client;
import p2.Greeting;
import p2.NewYearGreeting;

public class GreetingMain {
   public static void main(String args[]) {
       Greeting greeting = new NewYearGreeting();
       greeting.methodname();
  }
}


The package names are typed in complete lower-case
packages can be nested 
 greeting.client

package names are usually, the reverse of a web site doman name and sub domain name

package com.google.photos;

package banking.sc.loans;

package banking.sc.insurance;

package banking.dbs.

In  a typical java project, the following package names  
 DTO s are alternatively called with different names like DVO, BEANS
  com.pms.dto  
  com.pms.service
  com.pms.dao
  com.pms.client
  com.pms.payments
  com.pms.delivery
  com.pms.constants 
      public interface AllConstants {
       public static double DISCOUNT_PERCENT = 5;
     }


pms.jar

A few buit in java standard edition packages

   java.lang :   This package contains the CORE (the fundamental ) classes and interfaces of Java
          Object  String, StringBuffer, StringBuilder  : used to work with string manipulation
        wrapper classes like  Byte, Integer, Long....
     System, Comparable
  java.util :  List, 
  java.io
  java.util.concurrent
  java.sql
 javax.sql

   rt.jar
  public class Student extends java.lang.Object{

  }
 
All packages in java are usually compressed in a ZIP file of somename

the file extension of a java zip file is JAR (Java Archive)

Java access specifiers. 
 These are the keywords which declare the visibility/accessbility scope of 
   a class
   an interface
   or member of a class or an interface

There are four access levels in java. For three access levels, keywords are ther,

 private 
 protected
 public


1. private members are visible only inside the class in which they are declared
  e.g.
   class A {
  private int i;
  private void test(){  }
    }

2. public members are visible in any class of any package
 
3. protected members are visible in
  (i) the same class
 (ii) different class of the same package even if the class is not a sub class
 (iii) different class of the same package even if the class is a sub class
 (iv) different class of a different package if the class is a subclass

4. default. If we don't use any of public, private, protected keywords to declare a class itself then all the members of a class belong to  default category
  e.g
    class A {
     int i;
     void m1(){  }
  }

  (i) the same class
 (ii) different class of the same package even if the class is not a sub class
 (iii) different class of the same package even if the class is a sub class


the java.lang and its important class(es)/interface(s)
 This is the fundamental package (the core package) which contains all the fundamental classesa nd interfaces required by almost every java program (every .java file)
 
A few classes and interfaces
   (i)Object  class
 (ii) Comparable interface
 (iii) Class  class
  (iv) String, StringBuffer, StringBuilder classes
  (v) Wrapper classes  -  Integer, Byte, Short, Long, Float, Double, Character,Boolean

the Object class and its methods
  Th Object class is an automatic/implicit super class of all  java classes

 A few methods of it
  1.  String toString()  : This method is used to return a string description of a class/object. We need to override this method in our own java classes, to get the relevant output
 2.Class getClass : this method gets us the Class object of a given object
3. equals() : this method's purpose is to check whether two objects of a given class are equal eaccording to the data in them
  the built in functionality of the equals() method is that it compares whether two given object references point to 
 the same physical object in memory 
4. hashCode(). this method returns the hashCode of a object
  What is a hashCode ?
    is an integer. 
  By default, hashCode of an object returns an integer which indicates the memory cell address where a given object is stored

5. wait() notify() notifyAll()

6. finalize() - deprecated
For the purpose of efficient working with Java collections hash* related stuff, we need to override the hashCode() method oursevles

What is hashing ?
   It is technique which is used to store and retreive (find) objects efficiently in memory

  	Product p1 = new Product(101,"Mobile");
	Product p2 = new Product(102,"Charger");


what we write is the below one

	System.out.println("P1 = "+ p1);
	System.out.println("P2 = "+ p2);

What it becomes is the below one

	System.out.println("P1 = "+ p1.toString());
	System.out.println("P2 = "+ p2.toString());


Class getClass()

Every object loaded into the memory, has an object of a Class class associated with it

    Class c1 = p1.getClass();
     c1.getName();

______________________________________________________________________
Day 7 30/AUG/2022

 
  Client/Main -> Service  (contains method calls to objects which contain logic) ->

Garbage collection. It is the process in which the Garbage Collector

 Customer c1 = new Customer();
  c1.setX()
  c1.setX()
  c1.get()
  c1.setX()
  c1.getX()
  c1 = null; // this will disconnect the pointer c1 to the object it points
 Customer c2 = new Customer();
  c1.setX()
  c1.setX()
  c1.get()
  c1.setX()
  c1.getX()
  c2= null;
 Customer c3 = new Customer();
  c1.setX()
  c1.setX()
  c1.get()
  c1.setX()
  c1.getX()
  c3 = null;
 public class Customer {

  protected void finalize() {
  // some code here.. that releases/closes any system resources
 // any data base connection is closed 
 // any network connection is close
 // any file is closed
   }
}

The Comparable interface  : It has a single abstract method.
  (Any interface which has a single (and only single) abstract method is called a functional interface)


The method is compareTo(Object o) and is used to compare two objects against their natural order (natural sequence)

    React Js  Angular  Vue Js

 public int compareTo(Object o) {
     String temp=  (String) o;
    return this.compareTo(temp);
  
  }




Any interface which contains single abstract method and zero or many default/static methods is called a functional interface


public class CircleImpl1 implements Circle {
  public void area(double radius) {
  // some code here
  }

}


	Circle c4 = r->System.out.println("Radius="+r);

 Circle c4 = new CircleImpl1();


WRAPPER CLASSES, What are they ?
  These are the classes, which WRAP primitive data type variables, into objects

  e.g
   instead of saying

   int i = 10;
   we say
      Byte b1 = 10;
    Short s1 = 10;
      Integer i = 10; 
    Long l1 =10L;
   Float f1 = 10.23f;
    Double d1 = 10.23;

   char - Character
  boolean - Boolean


  Byte Short Integer Long Float Double Character Boolean

  LinkedList<Integer>  list = new LinkedList();
   int i =10;
  list.add(i); // incorrect
  list.add(new Integer(10));


What is the use of wrapper classes, or why cannot I just use variables of primitive data types ?
   Wrapper classes are used in collection framework,  collections don't accept  primitive variables in them


String, StringBuffer, StringBuilder

the above three classes used to work with strings


STRING POOL, (string constant pool), what is it?
  It is a part inside the HEAP memory, in which String class objects are exclusively stored


We can create an object of  a String class using two possible syntaxes

1. just like a primitive variable
      String s1 ="Java";
2. We can also create using the "new" operator

   String s2 = new String("programming");

String class objects created using the #1 approach are stored in STRING POOL, where as String class objects created using the#2 approach are stored on HEAP

String literal: any free flowing text enclosed in "" is a String literal. e.g.  "hello" , "java"

Everytime JVM notices a string literal, it creates an object of  the String class using approach 1 and then stores it in the string constant pool

 String s1 = "Java";  //10
   s1 = s1 + "programming"; //11

 Java
 Java Programming
 Programming

Objects of the String class are IMMUTABLE. which means, we cannot modify the content of a String class object after it is created, everytime , we try to modify, it creates a brand new object and stores it in the pool

  toLoweCase()  toUpperCase()  equals() equalsIgnoreCase()   compareTo()
 
 indexOf()  indexOf()  lastIndexOf()  lastIndexOf()   length()  charAt() 

  substring()  startswith()  endswith()


StringBuffer and StringBuilder. 
These two are used to work with MUTABLE strings which means we can modify objects

StringBuffer sb1 = new StringBuffer("hello");
   sb1  = sb1.append(" world!");
 
  insert, reverse, delete, 

StringBuffer vs StringBuilder. 
  Methods of StringBuffer are synchronized
  Methods of StringBuilder are not synchronized

Synchronized is a topic related to multithreading.


     - .Object class
    .Comparable interface
    - .Class class
    - .String, .StringBuffer, .StringBuilder classes
    - .Integer, .Byte, Short, .Long, .Float, .Double, .Character, .Boolean wrapper classes

Math ;  this class contains all "static" variables and methods

NOTE. All classes/ interfaces of java.lang package are automatically imported into all .java files


Method overriding WRT access specifiers
In method overriding, the  overriding version cannot be more restrictive than its parent version

e.g
   class A {
  private void m1() {  }
  }
  class B extends A {
   protected void m1(){  }
  }

Exception Handling in Java.

What is an Exception ?
  It is a problem that occurs during the runtime (during the execution time) of a program

When an exception occurs, the JVM terminates the program from that line which caused the exception.

Exception handling. It is a way of telling the JVM to continue to program execution, by ignoring the exceptions that occur using some special syntax.

 try and catch

Every exception that occurs is considered as an object one special class.
 
 AritmeticException,  NumberFormatException, ArrayIndexOutOfBoundsException
	
  IOException,  NullPointerException, ClassCastException, ClassNotFoundException, 
 
 InterruptedException, SQLException


Java Exception classes. These are the special classes related to exceptioni handling. 
Anytime if some exception occurs, JVM creates an object of the suitable exception class and throws that object

 int i  = 10/ 0;  ArithmeticException
 int num[] = {1,2,3};
   Sop(num[5]);  //   ArrayIndexOutofBoundsException


Java Exception class hierarchy

                               OutOfMemoryError    StackOverflowError


The java.lang.Throwable is the super class of all exception related classes

Throwable has two immediate subclassses,   Exception, Error

 Problems related to application/coding fall into the category of Exception
 Problems related to JRE like memory issues fall into the category of Error  

 Exception class has a bunch of child classes.  e.g    IOException, SQLException, ClassNotFoundException, RuntimeException


 RuntimeException has a bunch of child classes.  e.g  NullPointerException, ArrayIndexOutOfBoundsException, AritmeticException


Java Exception handling related keywords.

   try  catch  finally   throw   throws

 Any code that we suspect to possibly cause an exception is placed inside a block of code surrounded by try eyword


     try {
      int i = 10*2;
     int k = a/b;
     int j = 1+2;
     System.out.println("hello");
     int i = Integer.parseInt("10 ");
      System.out.println("world...");
          System.out.println("hello world..");
               Customer c1 = null;
	String s1 = null;
	c1.custid=101;
	System.out.println(s1.length());	
	System.out.println("java programm..");
	int num[] = {1,2,3,4,5};
	System.out.println(num[0]*2);
	num[100] = 2;
	System.out.println(num[1]+2);
  }  catch(ArithmeticException    e) {
           System.out.println(e);
   }
catch(NullPointerException    e) {
           System.out.println(e);
   }
catch(ArrayIndexOutOfBoundsException    e) {
           System.out.println(e);
   }
catch(NumberFormatException    e) {
           System.out.println(e);
   }
 

When the program flow jumps from try to catch, then after catch block is completed, it will not go back to try 

 
 
There can be more than one catch block for a try block..















try  {
  // line 1 of database code
 // line 2 of database code          SQLException
 // line 3 of database code

} catch(Exception e) {
     Exception e = new SQLException();
   e.getErrorCode();
}
catch(SQLException e) {

   e.getErrorCode();
}

     try {
      int i = 10*2;
     int k = a/b;
     int j = 1+2;
     System.out.println("hello");
     int i = Integer.parseInt("10 ");
      System.out.println("world...");
          System.out.println("hello world..");
               Customer c1 = null;
	String s1 = null;
	c1.custid=101;
	System.out.println(s1.length());	
	System.out.println("java programm..");
	int num[] = {1,2,3,4,5};
	System.out.println(num[0]*2);
	num[100] = 2;
	System.out.println(num[1]+2);
  }  catch(ArithmeticException | ArrayIndexOutOfBoundsException 
| NullPointerException | ...    e) {
           System.out.println(e);
   }

 
the finally block. 
   It is placed after the catch block and it is used to contain the code that releases the resources if opened any inside the try block

 try {
    // some code here opens a file
    // some code here opens a DB connection
  } catch(ArithmeticException e) {

  }   

    // the code here closes the file that is opened in try block
    // the code here closes the DB connection that is opened in try vlock


Creating a user-defined exception class (creating a custom exception)

To create our own exception class , we should define a class that extends any of the exception classes

 e.g.

    class TestException extends Exception {

   }

  class TestException2  extends RuntimeException {

  }

  class TestException3 extends TestException {

  }

  class TestException4 extends  NullPointerException {

  }

All built in exceptions are thrown by JVM.

Apart from this we can explicitly throw our own defined exceptions

the "throw" keyword.  It is used to throw an exception wantedly

throw exception-object;   // where exception-object is an object of any exception class

e.g.

   throw new NullPointerException();

   ArithmeticException e = new ArithmeticException(); 
   throw e;

public class InSuffcientFundsException extends Exception {
  // some reasonable code here
 }

public class BankingOperations {
 
  public void deposit(int actNumber, double  howMuch) {

  }

   public void withdraw(int actNumber, double howMuch) {
     
          throw new InSuffcientFundsException();
     
   }

}



public class Test {

   public static void goodAfterNoon()  {
     // some code here which causes an ArithmeticException
   
  }

  public static void goodMorning() {
 	
   }


  public static void goodEvening() {

   }

    public static void main(String args[]) {
         
   }

}

There are two types of types exceptions 

  1.  those which are under the control of the programmer   e.g   /0  invalid array index, null 
 2. those which are beyond control of the programmer

unchecked exceptions. An unchecked exception is that one where the compiler won't check whether tthe programmer is surrounding a piece of code causing an exception which is fixable  by him/her

checked exceptions represent those problems which are beyond the control of the programmer. If we don't use the surrounding try catch for the code related to checked exception, then the compiler won't compile that code

The compiler checks for such code whether we have used the surrounding try..catch , and there fore they are called as echecked exceptions

 int i =10/1;  
  String s1 = null;
 int x =    s1.length();

 try {
    FileReader fr = new FileReader("hello.txt") 
   } catch(FileNotFoundException e) {
             fr =  new FileReader("the same file name in a different computer")
    }
 try {
     DriverManager.getConnection("the database computers IP address", "username" , "password");
 } catch(SQLException e) {  }
 
 what if...not.. exists.. not turning


All IMMEDIATE subclasses of the Exception class  at any depth down the line (Except  RuntimeException class and its children) belong to the checked exception category



public class InSuffcientFundsException extends Exception {
  // some reasonable code here
 }

public class BankingOperations {
 
  public void deposit(int actNumber, double  howMuch) {

  }

   public void withdraw(int actNumber, double howMuch)  throws InSufficinetFundsException {
     if(howMuch > actNumber.getBalance()) {
        	
	  throw new InSuffcientFundsException();
             
     }
     

  public static void main(String argsp[])  throws InSufficientFundsEception  {
    	
    new BankingOperations().withdraw(1234, 1000);
  
  }
   }

}

For any code that causes a checked exception, we have to follow one of the following rules
 1.  EITHER we have to use a surround try ..catch block for that checked exception
 2. OR, we have indicate that problem in the method's declaration using the "throws" keyword , so that the callers of the method are informed about the problem

_______________________________________________________________
DAY 8 - 31/AUG/2022

Define the following custom exception classes and demonstrate the code to throw in appropriate situateion

1.  EmployeeNotFoundException
2.  InvalidUsernameException
3. InvalidCardException

To demonstrate the EmployeeNotFoundException, use the following usecase

  1. Employee.java (empid, empname,salary)
  2. EmployeeDataStore.java (Inside an array,store employee objects)
      e.g
               public static  Employee e[] =  {
		 new Employee(101,"Scott",5000),
		 new Employee(101,"Scott",5000),
		 new Employee(101,"Scott",5000),
		 new Employee(101,"Scott",5000),
		 new Employee(101,"Scot",5000),			
		}
https://www.somesite/com/api/employee/101
  3. EmployeeDAO.java (interface)
       public abstract Employee findEmployee(int empid) throws EmployeeNotFoundException;
       public abstract void showAllEmployees();
       public abstract int getEmpSalary(String empname);
      public abstract void updateEmployeeName(int empid, String newName) throws EmployeeNotFoundException;
      public abstract void updateEmployeeSalary(int empid, int newSalary) throws EmployeeNotFoundException;

  4. EmployeeDAOImpl.java implements EmployeeDAO
      this java code provides the logic implementation for the EmployeeDAO interface
  5.EmployeeService.java  (interface) : this interface contains exactly the same methods of the EmployeeDAO.java

     public abstract Employee findEmployee(int empid) throws EmployeeNotFoundException;
       public abstract void showAllEmployees();
       public abstract int getEmpSalary(String empname);
      public abstract void updateEmployeeName(int empid, String newName) throws EmployeeNotFoundException;
      public abstract void updateEmployeeSalary(int empid, int newSalary) throws EmployeeNotFoundException;

 6. EmployeeServiceImpl.java  implements EmployeeService
     // 











2.  Develop one case study to demonstrate the Hotel room reservation it should support the following features
           a.  Display a list of rooms with the details as follows
                   serial.num    hotel name    room-type   cost-per-day  availability 
                       1               Hotel-1         standard       50             yes
                       1               Hotel-1         standard       50             yes


            User-Menu
             1. Book hotel
             2.Exit
            
              Please enter your choice: 1
 
              Please enter customer details:
                Customer Name:
                No of persons:
                Contact number:
        

 A service class is something which provides the abstraction for any kind of service

e.g


 com.ems.dao
 public interface   EmployeeDAO {

  }  

 public class EmployeeDAOMySQL implements EmployeeDAO{

  }

 public class EmployeeDAOMongoDB  implements EmployeeDAO{

  }

 public class EmployeeDAOArrayStore implements EmployeeDAO{

  }


com.ems.service
 public interface   EmployeeService {
  // as of now this one contains exactly the same methods of the DAO interface
   // however, this interface is not restricted or not limited to contain ONLY the methods of DAO interface
  // but it can also contains any additional methods as needed which will be known during the time the 
 // project evolves
 // sending an email-acknowledgement
   public void sendEmail(String toEmailId);
  }

  public class EmployeeServiceImpl 
   // will create an object of DAO
 EmployeeDAO edao = new EmployeeDAOArrayStore();
   public void sendEmail(String toEmailId) {
  // send email using Gmail server, hotmail server
   }
 }




public class TestException extends EmpNotFoundException {

}

public class OtherException extends Exception {

}
public interface A {
   public void test() throws {
    }
}
public class B extends A {
   public void test() throws TestException {

    }
}

________________________________________________________________
day 9 01/SEP/2022

Method overriding and "throws" 

In method overriding, a child version cannot throw broader checked exceptions other than it's parent, 

A child version can throw  (means can declare in it's "throws")  
  (i) the same exception as it's parent version
  (ii) none
 (iii) the child class of the exception declared in the parent version

JAVA MULTITHREADING

What is mutltithreading?
  It is a way in which different parts of the same progam are executed concurrently* by the execution environment


  public class Test {
    public static void main(String args[]) {
   m1();
  }

   public static void m1() {
    m2();
   }

  public static void m2() {
  m3();
  }

  public static void m3() {

  }
 

 }


Java provides the facilities to created multithreaded programs

What is a Thread ?
  It is a memory stack on which the code is loaded and executed.

Creating threads in java is possible by creating an object of a built in class "java.lang.Thread"  or sub class of it

Thread t1 = new Thread();

Thread t2 = new Thread();

The java.lang.Thread class.    This class is used to create new threads,

There are various methods that this class offers to work with threads

  Thread()
  Thread(String threadName)
  Thread(Runnable r)
  start()
  run()
  sleep() 
 
  Working with creating multithreaded program invovles the following steps
 
1. Create a class that either extends the java.lang.Thread class and override the run() method in that class
                  or
      create a class that implements the java.lang.Runnable interface and override the run() method in that class


2. Create an object of the class created in step-1 

3.  invoke the start() method on the object created in step-2

4. now the start() method internally makes an implicit call to the run() method, by loading the code of the run() method on to the thread (memory stack) that is created when step 2 is executed


Multithreading use cases
 (i) server development
 (ii) gaming applications
 

Classes and interfaces related to Thread programming Java

 Thread class
 Runnable interface
 ExecutorFramework : It is a bunch of classes/interfaces for with more facilities
 Future
 Join/Fork framework:



class CircleThread extends Thread {
   public void run() {
   // logic to print the area of circle
   }
}
class SquareThread extends Thread {
   public void run() {
   // logic to print the area of square
   }
}
class RectangleThread extends Thread {
   public void run() {
   // logic to print the area of Rectanlge
   }
}

public class Main {
    main(....) {
   new CircleThread().start();
   new SquareThread().start();
  }
}

class CircleThread implements Runnable{
   public void run() {
   // logic to print the area of circle
   }
}

class SquareThread implements Runnable{
   public void run() {
   // logic to print the area of square
   }
}

class Rectanlge Thread implements Runnable{
   public void run() {
   // logic to print the area of rectangle
   }
}


class Main {
  p s v m (...) {
    new Thread(new CircleThread()) .start();
  }
}


the sleep() method.  It is used to purposely pause a thread's execution for some specified time

  public static void sleep(long milliseconds) throws InterruptedException

Thread life cycle and different states of  a thread

NEW 
READY-TO-RUN (RUNNABLE)   (waiting for JVM to pick its code and run)
RUNNING   (jvm is actually running its code currently)
PAUSE/BLOCK/WAIT  
DEAD


the currentThread() method. This method returns a pointer to the current thread

Thread.currentThread();

Thread priority: It is a integer given each thread that is loaded into memory.
Thread priority is used by the JVM to decide which thread to give the priority to execute code
The higher the priority , the higher the JVM chance to run it

The PRIRIOTY RANGE CAN BE  between 1 and 10  (including 1 and 10)

More than one thread can have the same priority, in this case, the JVM chance is given in a round robin fashion

The thread class has a few constants related to priority called

  Thread.MAX_PRIORITY =10
  Thread.MIN_PRIORITY= 1
  Thread.NORM_PRIORITY = 5;

The thread class provides to  change or to read the priority of thread

  t.setPriority(5);
  t.getPriority();

t.getName() t.setName()

Thread synchronization. It is way to solve or overcome race condition

What is race condition?
  It is the situation in which more than one thread tries to access the code the same object concurrently (we can also say this as,  a situation in which more than one thread tries to access a shared resource concurrently)


Every object loaded into memory has a MUTEX (Mutually Exclusive ) lock with it

We can synchronize other object's code by simplying using that object in a synchronized() block syntax

 e.g
   BankAccount b1 = new BankAccount();
    synchronized(b1)  {
       // some code here
   //e.g b1.withdraw(100);

  }


When a thread starts working with a synchronized code on an object, then it applies lock on all synchronized code of that object

wait() method. It releases the lock temporarily , (the lock that it acquired)
notify() method. it nofities the wait() ing method, to require the lock
notifyAll(). notifies all wait() ing threads

the above methods can be called/used ONLY FROM INSIDE a "synchronized" code 


PRODUCER-CONSUMER PROBLEM

flag = false
i =0;
producer has no lock
consumer has no lock
producer started run() method
    while(true) {
     q.put(i++);   
}

 put() started running when i is 0
flag changed to true
produced 1

__________________________________________________________________________________________________
DAY 10 02/SEP/2022

ExectutorFramework.   It is a group of classes and interfaces which are used to work group of threads easily

java Callable and java Future : These are used generally when working with executor framework

Callable is an interface which is same as Runnable, with one difference that the Callable's methoed call() returns the computed value where as Runnable's method  run() does not return a value

Future holds an object reference to a value that will be produced at some time in future.  The code that produces the object at some time in future is an asynchornous operation

  Future<Employee>  empid = ... some code here which will connect a remote database and fetches the empid

      greetGoodMorning();
     Future<boolean>   future = fillWater(); 40 mins
      gotoGrocery();
      greetGoodEvening();

   // may be a 20 lines later. I need the value of future...
 
	if(future.isDone() )
            temp = future.get();

The ExecutorService : This is a service that points to bunch of threads to which we can submit takss using Callable or Runnable and get the results as applicable by Future<T>
 
 e.s
    ExecutorService es1 = Executors.newFixedThreadPool(3);
        Future<Integer> f1 = es1.submit(new IntegerCallable());
      System.out.println(f1.get());



JAVA IO STREAMS AND FILES

The word stream has a different meaning based on the situation it is discussed in.
 
  if it is WRT java io  then a stream is a collection memory cells which acts as a data source for input and output destination

  if it is WRT java 8 features, then a stream is a collection of data items (may be object of Employee, Customer) which are processed  using a convenient syntactical way ratherthan the class for loop

FileInputStream   fin  = new FileInputStream("hello");

File : this is a class that include a bunch of methods related to created/deleting files and directories and also  reading the file information such as file operation permissions

Java Collection api  - It is a bunch of interfaces and classes  that come in some packages
 These classes and interfaces allow to work easily with  various data structure models such as doubly linked lists, binary trees, hashing, dynamic arrays

C++ STL

C pointers and data structures


REST context

Programming 
 api (appication programming interface)


  Iterable ->   Collection ->  List ->  LinkedList, ArrayList, Vector

 Iterable -> Collection -> Set  ->   TreeSet, HashSet, LinkedHashSet

LinkedList list  = new LinkedList();

TreeSet set = new TreeSet();

HashSet set1   = new HashSet();

ArrayList  list1 = new ArrayList();


 list.add()
 set.add()
  set1.add()
  list1.add()

  A      10 20 30 

 B    10 20 30 40 50 60

  a.retainall(b)

What is a  collection ?
  It is a group of objects.   e.g  A group of integers, strings, Customers, Employees

Collections are of two types
  (i) generic collections : which contain same type of objects like all strings, all students, all customers
 (ii) non generic collections : which contain different type of object like a mix of strings, integer, customer, student


   List list1 = new LinkedList(); // non generic way of doing, where we are not mentioning the type that we want to store in

   List<String> list2 = new LinkedList<String>(); // generic way of doing.


 Data items (objects) stored in a TreeSet are automatically sorted, because TreeSet is a SortedSet

 
 One very IMPORTANT thing about TreeSet is, if we want to store any object in TreeSet, then the class of that object MUST implement the  java.lang.Comparable<T> interface

Because, TreeSet internally runs the compareTo() method in a loop kind of array sorting loop to sort the elements stored in it
 
  for(int i=0;i<products.length;i++) {
 if(products[i].compareTo(products[i+1) {
      // code to shuffle  goes here
   }
  }

CTRL + shitft + t

Whereever there is a word Hash in  a class name then it means it makes use of hashCode() and equals() method as applicable
             HashSet LinkedHashSet 
add()
remove()
contains()
isEmpty()
clear()
size()


The contains() method. of the  java.util.Collection interface is used to find an object in a given collection. and the finding logic is different for different collections
  
 TreeSet  makes use of compareTo() method to search an object that we want.
 HashSet, LinkedHashSet makes use of both hashCode() and equals() method to search an object
 any List imlementation like ArrayList, LinkedList makes use of equals() method to search an object


The remove() method, of the java.util.Collection interface, is used to remove an object from a collection and works the same way of the contains() method across various classes

ITERATING ACROSS THE ELEMENTS OF A COLLECTION
  This can be done using one of the following ways
  (i) using the Iterator interface methods
 (ii) using the enhanced.. for loop
 (iii) (from Java 8) using the forEach() 

the  Iterator interface.   it has various methods that allow us to move to the next element in a collection, to remove it
 
boolean  hasNext()
Object next()
remove()

 

   Iterator<type> itr = collecttionobject.iterator();

the forEach() method of the Iterable interface. It takes a  java.util.function.Consumer<T> object and apply() ies the logic given to it on each object of the collection

    e.g collectioname.forEach(System.out::println);


List vs Set collection
   Sets do not allow duplicate elements where as List allows
   Lists have more additional support called index based operations, sets do not have the index based operations

  indexOf(Object ob)    get(index)  set(index, newObject)   remove(index)
____________________________________________________________________________________________
DAY 11 05-SEP-2022

There are various ways to create a collection for e.g.

 We can create an empty collection of any type like ArrayList, LinkedList, TreeSet, HashSet

ArrayList list1 = new ArrayList();

How do you create a LinkedList from an exisiting ArrayList ?

LinkedList list2 = new LinkedList(list1);


Arrays, Collections


The java.util.Arrays class has a bunch of static methods related to standarad array operations like sorting, searching.

One of the methods of the Arrays class is asList() which is used to create List

e.g.
  LinkedList  list3 = Arrays.asList(10,20,30);

The Collections class.  
 This class contains many utitily methods  sort(), unmodifiableList(), unmodifiableSet(), synchronizedList(array-list), synchronizedMap()
 
 LinkedList list4  = Collections.unmodifiableList(list3);

LinkedList list5 = Collections.synchronizedList(list3);

The java.util.Comparator interface.   This interface has a method compare(object1, object2). This method is similar to compareTo() method of Comparable interface.

In otherwords, we have to items to apply sorting logic.
   1. java.lang.Comparable ->   int compareTo(Object ob)
   2.  java.util.Comparator ->    int compare(Object ob1, Object ob2);

The java.util.Enumeration interface. It is same like Iterator interface, but used to work with collection like Vector

Vector vs ArrayList  :  both of these collections allow to work with dynamic arrays

Vector methods are synchronized whereas ArrayList methods are not synchronized

Vector is thread-safe  whereas ArrayList is NOT threadsafe


 ArrayList<Integer> al  = new ArrayList<>();
synchronized(this) {
   // your code on the array list  "al" goes here in a thread saftety manner
 }

The List interface has addtional methods, one among those is   listIterator() which returns a ListIterator interface object

The ListIterator is the child interface of the Iterator interface,  and it has additional methods which allow to traverse the List in backward direction also

List<Integer> intList = Arrays.asList(10,20,30,40,50);

  ListIterator<Integer> litr =  intList.listIterator();

    while(litr.hasNext()) {
    System.out.print(litr.next() +" ");
   } 

   while(litr.hasPrevious() ) {
    System.out.print(litr.previous()+" ");
  }

List vs Set :   Lists allow duplicate elements whereas Sets do not allow

Types of collections  based on their internal storage logic/model

ORDERDED COLLECTIONS.   These type of collections store the elements given to them in INSERTION ORDER.
 All java.util.List implementations like ArrayList, LinkedList are all ORDERED COLLECTIONS

SORTED COLLECTIONS. These are the ones which store the elements given to them in SORTED ORDER 
  TreeSet is the sorted collection

UN-ORDERED and UN-SORTED COLLECTIONS. These are the ones which NEITHER store the elements in SORTED form NOR in ORDERED form
 
 Anything whose name has "Hash" is an UNORDERED and UNSORTED collection



Map  in java.   A map is an object which stores data in terms of KEY-VALUE pairs


Examples of Map related classes in java.util are

   HashMap, TreeMap,  Hashtable,  LinkedHashMap

   Map<String, String> m = new HashMap<String,String>();

  m.put("Java","serverside");
 m.put("Angular","Frontend");


 Map<Product,Vendor>  prodVendMap = new TreeMap<Product,Vendor>();

   prodVendMap.put(new Product(,,,,), new Vendor(,,,) );
   prodVendMap.put(new Product(,,,,), new Vendor(,,,) );

 Each combination of KEY and VALUE of a given map is called an entry.
 
 entry is an object of an interface called Entry 

 Entry is a nested interface of the Map interface

 Map.Entry e = 

  

  public class Employee {
    empid;
    empname;
 }


 public class Project {
     projid; 
    projname; 
 }

 Remove implements Comparable,  remove @overiide compareTo() method from Employee.java 
  Change the Map object to TreeMap in the main()

All Hash* maps store their entries based on the hashCode() of the KEYs

The TreeMap stores it's entries based on the  Comparable.compareTo() of the KEYs, which means, it is compulsory for that class to implement the Comparable interface whose objects we want to use as a KEY in a TreeMap

HashMap vs Hashtable:

HashMap allows,  null for both key and value.   If we use null for key and/or value then it does not cause any compilation failure or runtime failure

Hashtable DOES NOT allow null for either key or value.  If we use a null for either key or value, then it results in a runtime failure of NullPointerException

TreeMap DOES NOT allow null key but value

HashMap vs LinkedHashMap:  The difference between these two is same as the difference between HashSet and LinkedHashSet


 public class Customer {
     private int custid;
     private String custname;
  }

 public interface CustomerDAO {
   public void addRecord(Customer c); 
   public Customer findCustomer(int custid) throws CustomerNotFoundException;
   public  List<Customer>   getAllCustomerRecords();
   public void updateCustomer(Customer newCustomer, int custid);
   public void deleteCustomer(int custid);  
 }

 public class ListCustomerDAO implements  CustomerDAO {
 // all implementation goes here
 // take any List such as LinkedList or ArrayList, to store/read/delete/update Customer objects
 }


 public interface CustomerService {
   public void addRecord(Customer c); 
   public Customer findCustomer(int custid) throws CustomerNotFoundException;
   public  List<Customer>   getAllCustomerRecords();
   public void updateCustomer(Customer newCustomer, int custid);
   public void deleteCustomer(int custid);  
 }

  public class CustomerServiceImpl implements  CustomerService{
 // wrapping of DAOImpl call goes here
 // override all methods and all the methods on the dao impl object
 }

 public class CustomerNotFoundException extends Exception {
   int custid; //  getters/setters/constructors/toString
 }

public class CustomerCRUDMain {
  public static void main(String args[]) {
    // CustomerService service =new CustomerServiceImpl();
     service.adRecord(new Customer(1,"A"));
  // like above statement demonstrate all CRUD operatios of the  CustomerDAO interface
}
}


Multithreading.

Can we start() a thread more than once ? If yes why, If no why ? If No , then what happens, if we call start() more than once,
  do we get compilartion failure
  do we get runtime failure
  no failure at all , but correct output


public class  DemoException extends Exception {

}






















 

























 
