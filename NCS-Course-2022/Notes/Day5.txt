https://us02web.zoom.us/j/85867722382?pwd=TXFMQmtDa0Fpc29WQjdCZS9RSWlBQT09

Java Full Stack
day-1 22/aug/2022

Java + Spring-Spring Boot Microservices + Angular

JAVA SOFTWARE

Java 8

STS  : Spring Tool Suite
Eclipse IDE

IntelliJ

The JAVAC command : It is used to compile a Java program

  javac filename.java
  
 dir
 
  javac Test.java --> Test.class (BYTECODE)

  del Test.class

 The JAVA command : It is used to execute a compiled Java program

   java <name of the .class file which has a public static void main(String args[]) method inside it>

  java Test

  Your name
  Your education
  Your programming/web development skills


JAVA  -> MYSQL -> JDBC -> HTML,CSS,JAVASCRIPT,BOOTSTRAP-> SERVLETS,JSP->HIBERNATE->SPRING CORE->SPRING JPA-> SPRING MVC->SPRING REST->SPRING SECURITY ->SPRING BOOT->MICROSERVICES->(TYPESCRIPT)ANGULAR->DOCKER->PROJECT


What is Java?
Java is a high level object oriented programming language.

Java is used for developing different kinds of applications

1. Desktop applications ->
           retail store billing systems
           schools data entry systems
           hospital data entry systems

2. Web applications  (SERVLETs/JSP)
             online shopping
             ticket application

3. Embedded systems
                 ATM
                 Gaming devices
                 Any other chip devices
           

Java Editions
     JSE -  Java Standard Edition
     JEE -  Java Enterprise Edition
     JME - Java Micro Edition

Java Version History

JDK 1.0 1996  JDK 18


Java 4 - 5 -6 - 7 - 8 - 9 -10-11 

JDK
JVM
JRE
JDKTOOLS


JDK : Java Development Kit

JVM : Java virtual machine

JRE: Java Runtime Environment

JDK tools : These are the commands such as JAVAC, JAVA, JAR from the  "bin" folder of the JDK installation such as ../JAVA.X.Y.Z	

What is JDK?
JDK = JRE + JDK TOOLS

JRE = Java Libraries + JVM

JVM : Java Virtual Machine, It is that part of JDK, which is responsible for loading and executing the compiled java code

JVM 
  loads the byte code (from the .class file such as Test.class) when we say sometihng like "Java Test"
  converts BYTECODE to NATIVE CODE (CODE THAT AN OS UNDERSTANDS)
  and then NATIVE CODE is given to OS
  
OS will then execute it

JIT : Just In Time  compiler inside JVM

What does JIT do ?
  or
 What is the purpose of JIT?
 
 It fastens the conversion of BYTECODE to NATIVE CODE (machine code / object code)


  Welcome.java 


What are java libraries ?
  These are nothing but the  IN BUILT  (or ready made) java programs 
  
 All these IN BUILT java programs are compressed into  file with a file extension called .JAR (java archive)

  
 banking.jar
  movie-tickets.jar


What are JDK tools ?
  These are nothing but the commands such as JAVAC,  JAVA, JAR (and many more) which sit inside the "bin" of JDK installation path


   int i = 10;     -32768  to +32767
  long int x =12345678;

    i = x; n 4000
   print(i)25435

Java Features
 Object Oriented
 Platform independent
  Robust
 Simple
 Multithreaded
 
Understanding IDE
  Integrated Development Environment

Eclipse
STS
IntelliJ


A project is a colllection of different files such as .java files, .html files, .css files, .js, 

A workspace is a folder used by IDE such as STS/ECLIPSE to store all our projects

Perspective: A perspective is the window layout and feature display in IDE

 Java Perspective 
 Java EE perspective

Create a new java project
Create new "Java class" under "src"
syso Ctrl+Space  System.out.println
Ctrl+D  this will delete the line where the cursor is


Data types in Java
There are 8 primitive data types ( fundamental data types / basic data types)

byte     short          int         long        float        double
 1          2               4           8             4              8

char -   2

boolean - vendor specific (unspecified in the specification)


SYNTAX
 
 DATATTYPE  name-of-the-variable1, name-of-the-variable2 ....;

 byte b1=10;
  short s1;
  


 Samsung 22 - 

Everything thing such as length,width,thickness, camera, charging, audio,...  are called as specifcation 
Blueprint

A - high   10 colors

B - medium  5 colors

C-  poor  12 colors


if( expression ) {
    code to execute if expression is true
} else {
   code to execute if expression is false
}

----------------------------------------------------------
DAY-2 23/aug/2022

Casting and conversion

Casting and conversion refers to the process of changing the data type (or class/interface type) of a variable  (or an object )


byte v1 = 200;
int v2 = 200;

  v1 = v2 ;  //  we are trying to assing int (v2) to byte (v1);

 lower-data-type-variable = (lower-data-type) upper-datatype-variable;

 v1 = (byte) v2;


CASTING vs CONVERSION

 casting is an explicit action where we expliclity change wider type to narrow type

 conversion is an implicit action where narrow type is automatically changed to wider type


LOOPS

 A loop is a programming feature which


 while loop
 for loop
 do  while

for(part-1 ; part-2 ;part-3)

part-1 is for declarations or initializations
part-2 is for test condition (expression)
part-3 is for altering the value used in part-2

the do..while

do  {

   code block;
} while(test condition) ;


All number literals in java by default belong to "int" data type

  12 34 454 45 


   long x = 120L;

byte b1 = 20;  (- 128  to 127)

  b1 = (byte) (b1 * 2);  (40 is again inside -128 to 127)
         (int)

All decimal numbers belong to double data type in java by default
   float f1 = 12.3;
 float f1 = 12.3F;
  float f1 = (float) f1;


Class: A class in java can contain any of the following or none of the following 
  (i) variables
 (ii) methods (functions)
 (iii) constants
 (iv) nested classes (also called inner classes) 
 (v) enumerations
 (vi)nested interfaces (also called inner interfaces)
 



 syntax to declare a class

  class classname {
    list of variables
    list of methods
  list of nested classes
   list of nested interfaces
   list of enums    
  } 

 class Student {
   // list of variables
   int studentNumber;
   String studentFirstName;

  // list of methods
 void printStudentDetails(){
  System.out.println("Student Number = " +studentNumber);
   System.out.println("Student name = " + studentFirstName);
  }
 }




Object: An object is a special type of a variable whose data type is the name of a class (or an interface)


 datatype variable-name;
  int  x =10;
  byte z = 20;


         Student s1;

Members of an object. All items declared inside a class belong to an object and become its members

  how do we access the members that belong to an object
    object-name.membername

    s1.studentNumber = 101;
    s1.studentName="Scott";
   s1.printDetails(); // this line executes the printDetails() method of the object s1

Working with object, is a two step process

 #1. Declaring an object
               Student s1;  
   Declaration does not allocate space in memory to the members that belong to an object

 #2. Creating an object.
      Creating an object means, allocate space to the members that belong to an object. this is acheived
    by execute a line of code that contains the  new operator
     

 The new operator
    
   We use the new operator to create object

   syntax
       object-name = new class-name();

       s1 = new Student();


Product
   productId; (int)
   prodName;  (String) 
printProductDetails()


ProductMain1
   main()
   create two Product class objects
   fill the object data
   print them


Class and Interface naming best practice
  
  All classes and interfaces names are typed in PascalCase
  
 Employee
 Student
 EmployeeInsuranceDetails

 
All variable and method names are typed in camelCase

   firstName;
   lastName;


Movie ticket class and object.
  it should contain the relavant one or many methods to book tickets
  after tickets are booked,  it should then display
 
   Total Tickets available before booking
   Total tickets available after booking
    Total number of tickets booked

      if the number of tickets asked to book are more than the total number of available tickets, then a message something
 like insufficient tickets should be printed




PaySlipDetails

    double grossSalary=8000;

  deductions =   incomeTax, profidentFund, healthInsurance, carLoanEmi
  netSalary = grossSalary- deductions

 // print gross
 // print incomeTax
  // print..
 // print netSalary


PaySlipDetailsMain {

}


SalaryFinder {

  void   showSalary(String designation) {
     // using switch case display some salary  for a designation

 //  if it is manager 8K, clerk 5k, accountatnt 6k
   }
 }

 
SalaryFinderMain {
  public static void main(String args[]) {
   SalaryFinder finder = new SalaryFinder();
   finder.showSalary("manager");
   finder.showSalary("clerk");
  }
 }


Object of one class inside other class

class Address {
    String city;
    int zip;
    void printAddress() {
    System.out.println("City : " + city);
    System.out.println("Zip : " + zip);
  
  }
}
class Employee {
   int empCode;
   String empName;
   Address address = new Address() ;
    
   void printDetails() {
     System.out.println("Employee Code = " + empCode);
    System.out.println("Employee name = " + empName);
      address.printAddress();
   }
}

class EmployeeAndAddress {
   public static void main(String args[]) {


   Employee e1 = new Employee();
   e1.empCode=103;
   e1.empName="Scott";
   e1.address.zip=12346;
   e1.address.city="Some city";
 
    e1.printDetails();

Employee e2 = new Employee();
    e2.address=address;
    e2.address.city="Two city";

 }

}
  


static members and non static members inside a class

class A {
   int x;
  static int y;
 
   void m1(){

   }

   static void m2() {


  }
}


STATIC members appear as only one copy in memory for a class, no matter, whether we create 0 objects, 1 object , many objects of that class

There will always be one copy (one and only one copy) of a static member that exists in memory for  a class, even though we don't create an object, or we create 1 or more objects


There can be anything as a static or a non static member

There can be a block of code as static


What is the need for static ?
  Any thing which is best suitable to appear/occur only once need to be declared static


All static code (sometimes called static context)  is loaded into memory soon after it's .class file is loaded into memory

There can be any number of static blocks. 
All static blocks are merged into one according to their textual occurence and are executed soon after the .class file is loaded

 class X {
   static int v1;
  static void m1() {  }
   static{   }
   static class A {  }
  static interface B {  }
}


JVM makes a call to the main() method somehting like this one

  Test.main();  // classname.main()


Which members of a class are loaded first  ?
  static or non static 

We cannot use a non static code from inside a static code

class Test {
  int x = 10;
  public static void main(String args[]) {
   System.out.println(x);
  }

}

class Vendor {
   int vendorId;
   String vendorName;  
 ........
 
}

class Product {
   int prodId;
   String prodName;
   Vendor vendor;

}


class BankAccount {
    int actNum;
    double actBalance;
}


class Address {

 }
class Customer {
   int custId;
   String custName;
    BankAccount account;
    Address address;

}   

-------------------------------------------------------------------------
DAY-3 24/AUG/2022

Types of variables : 

1. Local variables
2. instance variables ( non static variables, fields, properties, attributes)
3. static variables (class variables)


1. Local variables.   These are declared inside a method and are local to the method inside which are declared

 e.g
    class Test {
     void method1() {
          int x=10, y=20;  // x and y are local to the method1
   }
 
    void method2() {
    int i=100, j=200;  // i and j are local to the method2
    int k;
    k++; // this is an compilaation error
   System.out.println(k); // this compilation error
   }

  }

  Local variables are not loaded into memory unless we assign them a value.
  Local variables are loaded into memory as soon as their method is loaded into the memory


class TestMain {
   public static void main(String args[]) {
   int x;
   x++;
    Test t1 = new Test();

       t1.method1() ;//  variables x and y are loaded into memory as soon as this line is executed
                            // variables x and y are removed from memory as soon as this method code is completed
      t1.method2(); // variables i , and j are loaded into memory as soon as this line is executed 
                           // however variable k is not loaded into memory and won't be in existence because there is no value to given it
                          
  }

 }

Local variables are stored in memory a partition named STACK


NON STATIC VARIABLES (INSTANCE VARIABLES)
Non static variables are declared inside the class declaration and outside of all methods 
They don't have a static keyword prefix
  byte short int long = 0
   float double = 0.0
   char  =  \u0000
  boolean  = false
  Any object reference (object name) will be null
 
 class Customer {  }
 class Student {   }
 class Product {   }
class TestMain {
    int x=15;    //  x, y , s1, c, s  are all instance variables
    int y;
    String s1="hello";
    String s2;
    Customer c1;
    Student std1 = new Student();
    Product p1 = new Product();


    void method1(int x, int y) {
  
     } 

    void method2() {
       int x;
    }

    public static void main(String args[]) {
    TestMain1  temp1 = new TestMain1();
   System.out.println(temp1.s1.length());
 System.out.println(temp1.s2.length());
     
   }
}

INSTANCE VARIABLES are loaded into memory and become into exisitence everytime an instance/object is created


  String s1;
  


class Customer {
   int custId;
   String custName;
   void printDetails(){
  System.out.println("Custid = "  + custId);
  System.out.println("Custname = "  + custName);
   }
}

class Student {
  int age;
 String name;
  void printAge() {
      System.out.println("Age = " + age);
  }
}

class Test {
   Student std1;  // null by default
   Customer c1;   // null by default
   String s1="Java is a programming lnauage";  // not null

   String s2 ;  // null by default
   public static void main(String args[]) {
   
    Test ob1 = new Test();
    ob1.std1.age=100;           // line 10
    ob1.c1.custId=1234;         // line 11
    ob1.c1.custName="Scott";   // line 12
    ob1.c1.printDetails();         // line 13
    ob1.std1.printAge();            // line 14
    System.out.println(ob1.s1.length()); // line 15
    System.out.println(ob1.s2.length());  // line 16

  }

}

All INSTANCE variables are removed from HEAP (Object heap) when a particular object is nullfied


class A {
   int x;
}

class Test{
 public static void main(String args[]) {
    A a1 = new A();
    a1 = null; // I am forcibly nullfying a1.  then all INSTANCE variables of a1 will be removed from HEAP
 }
 }


When are INSTANCE variables loaded into memory (HEAP) ?
  They are loaded when an instance is created

When are INSTANCE variables removed from memory (HEAP) ?
  they are removed when an object is destroyed.  object is detroyed when it is nullified.



STATIC VARIABLES ( class variables)

class A {
  static int x;
  static String s1;
 static Customer c1;
}

STATIC VARIABLES are loaded in method area

STATIC variables are loaded into memory as soon as the .class file is loaded 
STATIC variables are remvoed from memory as soon as the .class file is removed.

But when is the .class file remvoed from memory ?
  it is removed from memory when the JVM shutsdown

When does the JVM shut down ?
  when the program execution is completed



1. LOCAL VARIABLE
2. INSTANCE VARIABLE ( fields/ attributes/ properties)
3. CLASS VARIABLE


Class variables are stored on ____________
Instance variables are stored on ____________
Local varaibles are stored on ____________


class Test {

  public static void add(int x, int y) {
     int total ;
    System.out.println(total);
 }

 public static void main(String args[]) {
     add(1,2);
  }
}


public class customer-details {
   int Customer-Id;
 String  Customer-full-name;
   void PrintCustomerDetails() {

  }
}

class Address {
   static int zipcode=1234;
}
class Customer {
  int custId;
  String custName="Scott";
  Address address ;
}

class Student {
  int studentId;
  String studentName;
}

class Test {
   Customer c1 = new Customer();
 Student std1 = new Student();
  public static void main(String args[]) {
  Test t1 = new Test();
 System.out.println(t1.c1.address.zipcode);
  System.out.println(t1.std1.studentId);
  }

}


the "final" it has 3 different uses

1.  to declare constants
2. to prevent method overidding
3. to prevent a class from being extended/inherited


A constant is that data member whose value cannot be altered after it is assigned with a value for the first time

final int MAX_SCORE =100


All constants names are typed in UPPERCASE as a best a practice
If constant  name contains more than one word, then they are separated by an _

e.g
  final int MAX_SCORE=100;
  final int MIN_SCORE=20;

Note. Generally all constants are declared as static, it is not a rule though

class Test {
  static final int X=100;
  public static void main(String args[]) {
   Test t1 = new Test();
    Test t2 = new Test();
 }
}


the "this" pointer.
  
The JRE maintains a built in pointer,  this

The this pointer always points to the currently active object

Currently active object is that one, upon whose code JVM is currently executing

Encapsulation:  It is the process in which we bind (we encapsulate) both INSTANCE VARIABLES (data) and INSTANCE METHODS (code) into one single unit



Method overloading : Is the process in which, we can declare more than one method with the same name by following one rule

class Compute {
   public void add(byte x, byte y) {
    System.out.println("Inside two bytes version" + (x+y));
   }
   public void add(short x, short y) {
    System.out.println("Inside two shorts version" + (x+y));
   }
   public void add(int x, int y) {
    System.out.println("Inside two int version" + (x+y));
   }
   public void add(long  x, long y) {
    System.out.println("Inside two longs version" + (x+y));
   }
}


NOTE. When working with method overloading, it is required, that the different versions of the same method,
    (I) either must have different number of parameters
   (ii) OR, if they have same number of parameters, then their data types sequence must be different
  
 METHOD overloading, does not force that the  return type and access specifier to be NEITHER SAME NOR DIFFERENT

 class  Shape {

   area() // circle
   area() // square
   area() // triangle
 }

  class ShapeMain{

 }

class Address {
  private int zip;
 private   String city;
   getters/setters
}

class Student  {
    private int studentId;
    private String sname;
    private Address address;  
getters/setters
}
class Customer{
    private int customertId;
    private String cname;
    private Address address;  
getters/setters

}

class AddressOverload {
 
  public void printAddress(Student student) {
  // the code here should print the address of the student tobject
 }
  public void printAddress(Customer customer) {
  // the code here should print the address of the customer object
  }
}


class AddressOverloadMain {
  main(.......)  {
    // create an object address for student
   // create a student object, and fill stdId, sname, address 
   // repeate the above two for customer
  // create an object of AddressOverLoad
 // call the printAddress(Student)
  // call the printAddress(Customer)
}
}

Constructors:   
1 Constructor is a method of a class which has the same name as its class name (both spelling and case)
  
2. Constructor has NO return type

 e.g
       class Test {
           Test() {
            // some code here
        }
   }

3. Constructor is executed automatically ONCE per each object (and only time) during the object creation

4. Constructors are used to provide some initial values to the INSTANCE VARIABLES on an object

5. Default Constructor: A constructor that is automatically there for every class is called default constructor
 NOTE. Default constructor has NO PARAMETERS 
  Test t1  = new Test(10,100);
		Test t2 = new Test(20,200);
		Test t3=  new Test(30,300);
		
Test(int i, int j){
		System.out.println("hello from Test() cons...");
		this.i=i;
		this.j=j;
	}


class Engine {
   int cc;
   String model;
  getters/setters

}

class Car {
  String brand;
  Engine engine;
  getters/setters

}

Given a Car, we should get out the Engine from it and print cc, model


class BankAccount {
  int actBalance;
  String branchName;
  getter/setters
}


class Customer {
   int customerId;
   String customerName;
   BankAccount account;

getters/setters;
}


class CustomerMain {
  public static void main(String args[]) {
    // create an object of BankAccount
     BankAccount  b1 = new BankAccount();
              b1.setActBalance(10000);
              b1.setBranchName("branch-1");
   // create an object of Customer 
   Customer c1 = new Customer();
   // now fill the customerId;
      c1.setCustomerId(101);
  // now fill the customer Name
    c1.setCustomerName("Guest");
   // now insert the BankAcount object b1 into the customer object c1
      c1.setBankAccount(b1);
 }

}
___________________________________________________________________
DAY 4  25/AUG/2022

CONSTRUCTORS contd.

5. Default constructor
   A consrructor which has ZERO parameters is called default constructor
 
 e.g
       class Test {
         Test() {

     }

    }
6. Constructor overloading. We can overload constructors just like methods.   It means, there can be more than one constructor in a class. 

  e.g
    class Test {
        Test() {
         System.out.println("Constructor with zero parameters.  It is the default constructor");

     }

        Test(int i, int j) {
         System.out.println("Constructor with 2 parameters.  It is called the parameterized constructor");

     }

   Test(long i, int j) {
         System.out.println("Constructor with 2 parameters.  It is called the parameterized constructor");

     }


   }


public class Address {
     private int zip;
     private String city;

   // #1 default constr
  // #2 two parameter constructor zip, city

    getters/setters;

 }
 public class Customer {
  
      private int custId;
      private String custName;
      private Address address;


    // #1 default consructor
    // #2  Two parameter constructor  -- custId, custName
   // #3  Three paramater constructor -- custId, custName, Address object

 // getters/setters

      
 }

 public class CustomerConsMain {
    main(....) {
      //  #1 create a Customer with default parameters
     // #2  create a Customer object with two parameters
   //#3  create a Customer object with three parameters
  
    Address addr1 = new Address(); 
       addr1.setZip(1224);       addr.setCity("");
          Customer c1 = new Customer(param1, param2, addr1)

     Customer c3 = new Customer(1234, "Scott", new Address(param1, param2...) )

   // #4 print the c1 details
   // #5 print the c2 details
   //#6 print the c3 details

  // NOTE. for printing it is upto you
   }

 }

public class BankAccount {
   private int actNumber;
   private double actBalance;
   private Customer actCustomer;


   // #1  default cons (zero param cons..)
  // #2 two param cons .. actNumber, actBalance
  // #3  3 param cons.. actNumber, actBalance, actCustomer
 // getters/setters
 
  // method1  public void showBalance() {  Sop(actBalance)  }

  // # method2  public void withdraw(double howMuch)
 // while withdrawing, check if howMuch > actBalance.. print insufficient funds  otherwise withdraw
 // after withdrawing .. print balance before withdraw, and after withdrw

 // #method3 public void deposit(double howMuch)
 // just add howMuch to balance...
 // after depositing.. print balance before deposit and after deposit
 
  

}


public class BankAccountMain {
  main(...)  {
     // #1 BankAccount b1  with default cons
    // #2 BankAccount b2  with 2 param cons
   //#3 BankAccount b3  with 3 param cons

   // demonstrate withdraw and deposit on all b1, b2, b3
  // print the details of b1, b2, b3

  }
}


#7 the super()  constructor :  this one triggers call to the constructor of the immediate super class. (more on this during inheritance)

#8.  constructors can be declared using public, private, protected or default (no keyword) 

#9. Constructors CANNOT be static. if we try do so, it is a compilation failure

#10. Constrcutors CANNOT be final
 
#11. Constructors cannot be executed more than once

#12. the  this() constructor. There can be more than one overloaded constructor, and in such case, one version of a constructor can make a call to other version of a constructor using  this().   this() may take parameters


#13. If there is a call to this() then it MUST be the first statement

#14.  there is a tough competition between super() and this(), i.e
     super()  has to be the first statement (if we want to use super()  )
     this () has to be the first statement (if we want to use this()  )
     in otherwords, we cannot do something like the below 

    class A {

    A() {
    this();
    super();

   }
   A(int i) {

   }
   }

#15.  If we don't declare AT-LEAST (if we don't type) in a class's  .java file, then the compiler automatically adds the default constructor in that java file

  e.g
    what we type is the below one
    class Test {

    }
    what it becomes is the below one 
   class Test {
   Test() {

    }
  
  }


#16.  If we type atleast one constructor in a java file, then the compiler won't automatically provide the default constructor. we have to explicitily provide it


      what we type is the below one
    class Test {
     Test(int i) {

    }

  }
   what it becomes is the same. means, no default const (no param cons available)
      class Test {
      Test(int i) {

     }
    }


Arrays in Java.

 #1. An array is a collection of variables that have the same name with different index
 #2. Arrays in java are considered as objects , therefore we need to make of use of the "new" operator

      datatype name-of-the-array[] ;
      name-of-the-array = new datatype[array-size];

    int numbers[];  // only declaration happens. memory is not allocatedd
    numbers = new int[5] ; // now the array is created and memory is allocated to 5 items of the array

  datatype name-of-the-array[] =  new datatype[array-size];

   int numbers = new int[5]; // memory is allocated to 5 elements of the aray
 #1  five floats
 #2.  3 chars
 #3. 3 Strings
  #4.   3 Customers 
  #5.   3 Students


   int numbers[]  = new int[5];

All array elements are kind of instance variables of the respective array


 class Numbers {
      int numbers[0];
      int numbers[1];
     int numbers[2];
    int numbers[3];
    int numbers[4]
 }

Numbers numbers = new Numbers();
 

the "length" attribute of arrays.  Arrays in java like in JavaScript has a "length" 

ArrayIndexOutOfBoundsException : this is a class name from the Java library

If we refer to an array element beyond the array capacity, it is a successful compilation, but it fails during runtime with an exception called ArrayIndexOutOfBoundsException


Initializing an array. We can do this in two ways

1.   
datatype name-of-the-array[] = new datatype[] { val1, val2... valN };
 int numbers[] = new int[] { 10,23,45,54,56 };

2.   
datatype name-of-the-array[] = { val1, val2... valN };
 int numbers[] = { 10,23,45,54,56 };

Two dimensional array

 int numbers[][] = new int[2][2];

  String namesAndCities[][] = new String[3][3];
  
  
  int numbers[][] = {   
            { val1, val2, val3},
            { val1, val2, val3},
            { val1, val2, val3}
  };

  
  String strings[][] = {  
   {val1, val2, val3},
  {val1, val2, val3},
  {val1,val2,val3}
 };

 
the "enhanced for loop"  (also called as for..each loop)

for(Type t: arrayOrCollection) {

}

Java Command Line Arguments.
 
What are command line arguments?
  These are  the values that we can supply into the program
 VIA the command line (or console)

Part of the OOP, Encapsulation

Inheritance.
   In is an approach in Object Oriented Programming,  in which,
  one class inherits  the code/features of other class
  
 
  1. eliminating duplicate code
  2. acheiving POLYMORPHISM


class PermamentEmployee {
   private int empId;
   private String empName;
   private double grossSalary;
  costructors/ getters/setters/

  public void calculateNetSalary() {
   the net salary is calculated  by deducting all dedcutions from gross slaary
//  income tax + insuarance + emi + pf + hra 
  }
//  income tax + insuarance + emi + pf + hra 

}


class ContractEmployee {
   private int empId;
   private String empName;
   private double grossSalary;
  costructors/ getters/setters/

// fixed deduction of tax
  public void calculateNetSalary() {
   the net salary is calculated  by deducting fixed amount tax
   // fixed deduction of tax
  }
}


METHOD OVERRIDING.   
  It is an approach in which a child class redeclares a method (or any number of methods) of its parent class
 with same signature
 
 same signature means
  1. same return type
  2. same number of parameters
  3. same data type sequence of parameters 

In this explanation, the parent class version of method is called as overidden version
 the child class version of the method is called as overiding version
class A {
   void m1(int i, int j) {
   //some code goes here
  }
 }

class B extends A {
   void m1(int i, int  j) {
   //some code goes here
  }
}


class Test extends B{
    public static void main(String args[]) {
   B b1 = new B();
    b1.m1();
 }
}


A super class object reference can point to an object of any of its subclasses


A a1 = new A();

B b1 = new B();;

A a1 = new B();


-------------------------------------------------------------------------------------------
DAY 5  26/aug/2022


When a super class object reference points to an object of its subclass, then it has no knowledge about the 
exclusively declared members of the subclass.

It onlys know about the 
 (i) inherited members from the parent class
(ii) overriden members
 
  A a1 = new B();
class A {
   private int i;
   private int j;
 
   public void m1(int i) {

 }
  public void m2(int j) {

 }

}
class B extends A {
    private int x, y;
    public void m1(int i) {

    }
   public void m3(int j) {

  }
}

inherited members
overriden members
exclusive members

   
Employee e1;

PermanentEmployee p1 = new PermanentEmployee();
ContractEmployee c1 = new ContractEmployee();
  e1 = c1 ;  // line 1
  e1.showNetSalaryAfterDeductions(); // line2
   e1.printDetails();   // line 3
  e1 = p1;  // line 4
  e1.showNetSalaryAfterDeductions(); // line 5
   e1.printDetails(); // line 6
   
Abstract method. Any method which has JUST A DECLARATION, but no implmentation,
it is called as an abstract method.

Non abstract method . Any method which has an implementation is called no abstract method
CONCRETE methods.  Non abstract methods are also called as CONCRETE METHODS

abstract class: A class which contains ATLEAST one abstract method, is called as an abstract class


We cannot create an object for an abstract class


concrete class. A class with ZERO abstract methods inside it is called a concrete class


There can be an abstract class with ZERO abstract methods in it . (this is because, sometimes we may want to restrict people to create an object of our class)
abstract class Test1 {
    public void m1() { // some code here }
    public void m2() { // some code here }
    public void m3() { // some code here }
  }

abstract class Test2 {
    public void m1() { // some code here }
    public void m2() { // some code here }
    abstract public void m3() ;
  }

 class Test3 {
    public void m1() { // some code here }
    public void m2() { // some code here }
    abstract public void m3() ;
  }












class Test {
   public void m1() {
  // some code here
   }

  abstract public void m2() ;

  abstract public void m3();

  public void m4() {
  // some code here
  }

   abstract public void m5() {
   // some code here
   }

    abstract public void m6() {
  // some code here
    }
}



the "abstract" keyword. It  is used to declare abstract methods and abstract classes.


What are the abstract classes  and abstract methods  used for ?
   They are used in a situation, where there is a common code given by the parent class that is required by all children classes, and where there is a some functionlity  (some code) which is specific to each child


class FlightTicket {
  int flightNum;
  String origin;
 String detst;
   int depTime;
 
}

class EconomyTicket  extends FlightTicket{
   private String softDrinkName;
   getter/setter
  showBenefits() {
    boarding is oridnary
    seating is standard
   }
}

class BusinessClassTicket extends FlightTicket{
  private int freeExtraBaggageWeight;
  getter/setter
  showBenefits() {
     boarding is priority 
     seating is special seating
  }
}


bookTicket(FlightTicket t ) {

}

abstract class A {
    int i;
   abstract void m1();
}

class B extends A {

  void m1() {  } // overridden
   void m2() {  } // some exclusive method. neither inherited nor overridden
}

class C extends A {

  void m1() {  } // overridden
   void m3() {  } // some exclusive method. neither inherited nor overridden
}
class TestMain {
   public static void main(String args[]) {
          TestUtiliy.testMethod(new C() );
  }
 }
class TestUtitily {
   static void testMethod(A a) {
        a.m1();
   if(a instanceof B ) {
          B b1 = (B) a;
          b1.m2(); //works now
    } else  if (a instanceof C ) {
         C c1 = (C) a;
          c1.m3(); //works now

  }
}

if a is pointing to an instance of (object of) class B


Downcasting an object reference from parent class to child class name


PermanentEmployee i =10;
Employee x = 20;

 i =(PermanentEmployee) x;


The instanceof operator. It is used to check whether a given object reference points to an object of a specific class in need

A few points about an abstract class

1. We cannot create an object of an abstract class
2. abstract class can contain concrete methods and abstract methods
3. abstract class can contain constructors
4. An abstract method cannot be "final"
5. An abstract class can extend other class
6.An abstract can implement one or more interfaces 

V.IMP  If any class extends an abstract class, then that child class has to

EITHER override all abstract methods of abstract class , concretely

OR, the child class has to declare itself as abstract if it overrides few only method concretely

abstract class A extends Test {
   abstract void m1();
  abstract void m2();
   void m3() {}
    void m4() {}
}

abstract class B extends A  {

    void m2() {   // some code here }
   void m5() {  }
}
 
class C extends B {

    void m2() {  }
}

A a1 =new B();
  a1 = new C();

B b1 = new C();

class A {   }     class B {  }   class C  {  }

class D extends A,B,C {  } // this is not supported in Java, multiple inheritance


abstract class Shape {
    abstract void area();
    abstract void category();
   
}

class Triangle extends Shape {
    public void area() {  // some stuff here } 
}

class Rectanlge extends Shape {
  public void category() {  // some stuff here }
}

class MathAndScienceShape  extends Shape {
    public void area() { // some stuff here }
  public void category() {  // some stuff here }

}

class ScienceAndGeography extends Shape {

}

 DAO - Data Access Object
abstract class StoreData {
   abstract void storeInMongo();
   abstract void storeInMySQL();
   abstract void storeInOracle();
}




the super() constructor.  
   It executes a construtor of an immediate super class from within the constructor
 of a subclass
 
 super() .. is always there as a first statement in any constructor.

V IMP. When we create an object of a class, then, a list of constructors across all
 its super classes are executed from TOP to BOTTOM in descending order

 class A {   }
class B extends A { }
class C extends B {   }

the super keyword.  It is used to refer to the copy of a super class member from inside the code of a sub class member in case of duplicate names

 class A2 {
    int i =10;
    void m1() {
    System.out.println("m1 of class A ");
    }
  }

class B2 extends A2 {
   int i =20; 
   void m1() {
    
    System.out.println("m1 of class B");
   }
  void m2() {
    System.out.println("  I = "  + i) ; // this prints 20
    System.out.println(" super.i =  " + super.i); // this prints 10     
   m1(); // this calls  m1 of B
      super.m1(); // this calls m1 of A
   }
}


the  java.lang.Object class.  It is the implicit super class of all java classes.

class Test extends java.lang.Object{

}


the "final"  keyword. It has 3 uses

1. to declare CONSTANTS
2. to prevent method overriding
3. to prevent a class from being inherited 

final class A  {
void m1() {
      System.out.println("m1");
   }
 void m2() {
      System.out.println("m1");
   }
  void m3() {
      System.out.println("m1");
   }
  
}
class B extends A {
   void m1() {
     System.out.print("m1 of B");
    }
}


interfaces in java (with respect to versions upto  VERSION 7 (including 7).


An interface is a collection of 
  (i) CONSTANTS
 (ii) abstract methods

Interfaces are declared using the "interface" keyword

Interfaces ares are used to acheive 100% abstraction

interfaces are declared like the way classes are declared.

  interface interface-name {
    constant-1;
    constant-2; 
    constant-N;
 
   abstract-method-1;
   abstract-method-2;
   abstract-method-n;
 }


interface A {
 public static final int MAX_SCORE=10;
 public static final int MIN_SCORE=5;
public abstract void sum(int i, int j);
  public abstract void prod(int i, int j);

}

All data-items (data-members) such as MAX_SCORE,MIN_SCORE of an interface
are implicitly public, static, final.  which means, we can ignore those keywords.

All methods of an interface are implicitly public, abstract.

 A  a1 = new A(); // usesless-- because everything is abstract -- error

To make use of an interface, we need to create / declare a class that overrides all methods of an interface concretely and public ly


the "implements" keyword. This is used to establish a link between an interface and a class that  want to override the methods of that interface

class class-name implements interfacename-1, interface-name-2,interface-name-N {

}

In the following example, class TestA is said to implement the interface "A"
class TestA implements A {
public void sum(int i, int j) {  
  System.out.println("addition of i and j");  
}
  public void prod(int i, int j) {  }
  System.out.println("prod of i and j");
}

class TestMain4 {
  public static void main(String args[]) {
   A  ob1 = new TestA();
     ob1.sum(10,20);
    ob1.prod(1,2);
  System.out.println(A.MAX_SCORE);
  System.out.println(A.MAX_SCORE);

 }
 
}

To create a class that makes use of an interface different naming standards are followed as per the convenience

  the class-name + a suffix of the interface name

 e.g
   Test + A  = TestA // so that if we look at the class name we understand that class TestA isa class that implements interface

  the interface-name + a suffix of "Impl"

   e.g

   A + Impl = AImpl  // which means the class AImpl is an implementation of an interface A


One interface can have many implementation classes

e.g
   public interface StoreData {
     public abstract void insertRecord(Employee e);
    
  }
 
class MySqlStoreData implements StoreData {
   public void insertRecord(Employee e)  {
    // pull out the fields from e using something like e.getEmpId();
  // and then drop them in MySQL table
   }
}
 
class MongoDBStoreData implements StoreData {
   public void insertRecord(Employee e)  {
    // pull out the fields from e using something like e.getEmpId();
  // and then drop them in MongoDB
   }
}

class PdfStoreData implements StoreData {
   public void insertRecord(Employee e)  {
    // pull out the fields from e using something like e.getEmpId();
  // and then drop them in a pdf file
   }
}
 

Design a Banking operations

1. BankAccount as the parent class (with suitable parent class members)
2. SavingsBankAccount and CurrentBankAccount with suitable specific functionality of their own
       For e.g. SavingsBankAccount has a speficific functionaliy to itself  calculatSavingInterest
                   CurrentBankAccount has a specific functionality to itself  calculateOverDraftLimit
4. BankAccountUtility


1. LoanAccount
2. CarLoan,  HomeLoan, StudyLoan
3. LoanUtility


1. DeliveryPartner
2. OrdinaryDeliveryPartner, PriorityDeliveryPartner, InterntionalDeliveryPartner
3.

----------------------------------------------------------













